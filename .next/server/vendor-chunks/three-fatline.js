"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/three-fatline";
exports.ids = ["vendor-chunks/three-fatline"];
exports.modules = {

/***/ "(ssr)/./node_modules/three-fatline/dist/three-fatline.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/three-fatline/dist/three-fatline.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Line2: () => (/* binding */ Line2),\n/* harmony export */   LineGeometry: () => (/* binding */ LineGeometry),\n/* harmony export */   LineMaterial: () => (/* binding */ LineMaterial),\n/* harmony export */   LineSegments2: () => (/* binding */ LineSegments2),\n/* harmony export */   LineSegmentsGeometry: () => (/* binding */ LineSegmentsGeometry)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n\n\nconst THREE$2 = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  Box3: three__WEBPACK_IMPORTED_MODULE_0__.Box3,\n  BufferGeometry: three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry,\n  Float32BufferAttribute: three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute,\n  InstancedBufferGeometry: three__WEBPACK_IMPORTED_MODULE_0__.InstancedBufferGeometry,\n  InstancedInterleavedBuffer: three__WEBPACK_IMPORTED_MODULE_0__.InstancedInterleavedBuffer,\n  InterleavedBufferAttribute: three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBufferAttribute,\n  Sphere: three__WEBPACK_IMPORTED_MODULE_0__.Sphere,\n  Vector3: three__WEBPACK_IMPORTED_MODULE_0__.Vector3,\n  WireframeGeometry: three__WEBPACK_IMPORTED_MODULE_0__.WireframeGeometry\n};\n\n// support multiple method names for backwards threejs compatibility\nvar setAttributeFn$1 = new THREE$2.BufferGeometry().setAttribute ? 'setAttribute' : 'addAttribute';\nconst _box$1 = new THREE$2.Box3();\nconst _vector = new THREE$2.Vector3();\nclass LineSegmentsGeometry extends THREE$2.InstancedBufferGeometry {\n  constructor() {\n    super();\n    this.type = 'LineSegmentsGeometry';\n    const positions = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0];\n    const uvs = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2];\n    const index = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];\n    this.setIndex(index);\n    this[setAttributeFn$1]('position', new THREE$2.Float32BufferAttribute(positions, 3));\n    this[setAttributeFn$1]('uv', new THREE$2.Float32BufferAttribute(uvs, 2));\n  }\n  applyMatrix4(matrix) {\n    const start = this.attributes.instanceStart;\n    const end = this.attributes.instanceEnd;\n    if (start !== undefined) {\n      start.applyMatrix4(matrix);\n      end.applyMatrix4(matrix);\n      start.needsUpdate = true;\n    }\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox();\n    }\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere();\n    }\n    return this;\n  }\n  setPositions(array) {\n    let lineSegments;\n    if (array instanceof Float32Array) {\n      lineSegments = array;\n    } else if (Array.isArray(array)) {\n      lineSegments = new Float32Array(array);\n    }\n    const instanceBuffer = new THREE$2.InstancedInterleavedBuffer(lineSegments, 6, 1); // xyz, xyz\n\n    this[setAttributeFn$1]('instanceStart', new THREE$2.InterleavedBufferAttribute(instanceBuffer, 3, 0)); // xyz\n\n    this[setAttributeFn$1]('instanceEnd', new THREE$2.InterleavedBufferAttribute(instanceBuffer, 3, 3)); // xyz\n    //\n\n    this.computeBoundingBox();\n    this.computeBoundingSphere();\n    return this;\n  }\n  setColors(array) {\n    let colors;\n    if (array instanceof Float32Array) {\n      colors = array;\n    } else if (Array.isArray(array)) {\n      colors = new Float32Array(array);\n    }\n    const instanceColorBuffer = new THREE$2.InstancedInterleavedBuffer(colors, 6, 1); // rgb, rgb\n\n    this[setAttributeFn$1]('instanceColorStart', new THREE$2.InterleavedBufferAttribute(instanceColorBuffer, 3, 0)); // rgb\n\n    this[setAttributeFn$1]('instanceColorEnd', new THREE$2.InterleavedBufferAttribute(instanceColorBuffer, 3, 3)); // rgb\n\n    return this;\n  }\n  fromWireframeGeometry(geometry) {\n    this.setPositions(geometry.attributes.position.array);\n    return this;\n  }\n  fromEdgesGeometry(geometry) {\n    this.setPositions(geometry.attributes.position.array);\n    return this;\n  }\n  fromMesh(mesh) {\n    this.fromWireframeGeometry(new THREE$2.WireframeGeometry(mesh.geometry)); // set colors, maybe\n\n    return this;\n  }\n  fromLineSegments(lineSegments) {\n    const geometry = lineSegments.geometry;\n    if (geometry.isGeometry) {\n      console.error('LineSegmentsGeometry no longer supports Geometry. Use THREE.BufferGeometry instead.');\n      return;\n    } else if (geometry.isBufferGeometry) {\n      this.setPositions(geometry.attributes.position.array); // assumes non-indexed\n    } // set colors, maybe\n\n    return this;\n  }\n  computeBoundingBox() {\n    if (this.boundingBox === null) {\n      this.boundingBox = new THREE$2.Box3();\n    }\n    const start = this.attributes.instanceStart;\n    const end = this.attributes.instanceEnd;\n    if (start !== undefined && end !== undefined) {\n      this.boundingBox.setFromBufferAttribute(start);\n      _box$1.setFromBufferAttribute(end);\n      this.boundingBox.union(_box$1);\n    }\n  }\n  computeBoundingSphere() {\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new THREE$2.Sphere();\n    }\n    if (this.boundingBox === null) {\n      this.computeBoundingBox();\n    }\n    const start = this.attributes.instanceStart;\n    const end = this.attributes.instanceEnd;\n    if (start !== undefined && end !== undefined) {\n      const center = this.boundingSphere.center;\n      this.boundingBox.getCenter(center);\n      let maxRadiusSq = 0;\n      for (let i = 0, il = start.count; i < il; i++) {\n        _vector.fromBufferAttribute(start, i);\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));\n        _vector.fromBufferAttribute(end, i);\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));\n      }\n      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);\n      if (isNaN(this.boundingSphere.radius)) {\n        console.error('THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.', this);\n      }\n    }\n  }\n  toJSON() {// todo\n  }\n  applyMatrix(matrix) {\n    console.warn('THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().');\n    return this.applyMatrix4(matrix);\n  }\n}\nLineSegmentsGeometry.prototype.isLineSegmentsGeometry = true;\n\n/**\n * parameters = {\n *  color: <hex>,\n *  linewidth: <float>,\n *  dashed: <boolean>,\n *  dashScale: <float>,\n *  dashSize: <float>,\n *  dashOffset: <float>,\n *  gapSize: <float>,\n *  resolution: <Vector2>, // to be set by renderer\n * }\n */\n\nconst THREE$1 = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  ShaderLib: three__WEBPACK_IMPORTED_MODULE_0__.ShaderLib,\n  ShaderMaterial: three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial,\n  UniformsLib: three__WEBPACK_IMPORTED_MODULE_0__.UniformsLib,\n  UniformsUtils: three__WEBPACK_IMPORTED_MODULE_0__.UniformsUtils,\n  Vector2: three__WEBPACK_IMPORTED_MODULE_0__.Vector2\n};\nTHREE$1.UniformsLib.line = {\n  worldUnits: {\n    value: 1\n  },\n  linewidth: {\n    value: 1\n  },\n  resolution: {\n    value: new THREE$1.Vector2(1, 1)\n  },\n  dashScale: {\n    value: 1\n  },\n  dashSize: {\n    value: 1\n  },\n  dashOffset: {\n    value: 0\n  },\n  gapSize: {\n    value: 1\n  } // todo FIX - maybe change to totalSize\n};\nTHREE$1.ShaderLib['line'] = {\n  uniforms: THREE$1.UniformsUtils.merge([THREE$1.UniformsLib.common, THREE$1.UniformsLib.fog, THREE$1.UniformsLib.line]),\n  vertexShader: /* glsl */\n  `\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\tvarying vec2 vUv;\n\t\tvarying vec4 worldPos;\n\t\tvarying vec3 worldStart;\n\t\tvarying vec3 worldEnd;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\tvUv = uv;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\tworldStart = start.xyz;\n\t\t\tworldEnd = end.xyz;\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec3 ndcStart = clipStart.xyz / clipStart.w;\n\t\t\tvec3 ndcEnd = clipEnd.xyz / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd.xy - ndcStart.xy;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t// get the offset direction as perpendicular to the view vector\n\t\t\t\tvec3 worldDir = normalize( end.xyz - start.xyz );\n\t\t\t\tvec3 offset;\n\t\t\t\tif ( position.y < 0.5 ) {\n\n\t\t\t\t\toffset = normalize( cross( start.xyz, worldDir ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\toffset = normalize( cross( end.xyz, worldDir ) );\n\n\t\t\t\t}\n\n\t\t\t\t// sign flip\n\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\tfloat forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );\n\n\t\t\t\t// don't extend the line if we're rendering dashes because we\n\t\t\t\t// won't be rendering the endcaps\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t// extend the line bounds to encompass  endcaps\n\t\t\t\t\tstart.xyz += - worldDir * linewidth * 0.5;\n\t\t\t\t\tend.xyz += worldDir * linewidth * 0.5;\n\n\t\t\t\t\t// shift the position of the quad so it hugs the forward edge of the line\n\t\t\t\t\toffset.xy -= dir * forwardOffset;\n\t\t\t\t\toffset.z += 0.5;\n\n\t\t\t\t#endif\n\n\t\t\t\t// endcaps\n\t\t\t\tif ( position.y > 1.0 || position.y < 0.0 ) {\n\n\t\t\t\t\toffset.xy += dir * 2.0 * forwardOffset;\n\n\t\t\t\t}\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\toffset *= linewidth * 0.5;\n\n\t\t\t\t// set the world position\n\t\t\t\tworldPos = ( position.y < 0.5 ) ? start : end;\n\t\t\t\tworldPos.xyz += offset;\n\n\t\t\t\t// project the worldpos\n\t\t\t\tvec4 clip = projectionMatrix * worldPos;\n\n\t\t\t\t// shift the depth of the projected points so the line\n\t\t\t\t// segements overlap neatly\n\t\t\t\tvec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;\n\t\t\t\tclip.z = clipPose.z * clip.w;\n\n\t\t\t#else\n\n\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\t\t\t// undo aspect ratio adjustment\n\t\t\tdir.x /= aspect;\n\t\t\toffset.x /= aspect;\n\n\t\t\t// sign flip\n\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t// endcaps\n\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\toffset += - dir;\n\n\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\toffset += dir;\n\n\t\t\t}\n\n\t\t\t// adjust for linewidth\n\t\t\toffset *= linewidth;\n\n\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\toffset /= resolution.y;\n\n\t\t\t// select end\n\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t// back to clip space\n\t\t\toffset *= clip.w;\n\n\t\t\tclip.xy += offset;\n\n\t\t\t#endif\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t`,\n  fragmentShader: /* glsl */\n  `\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\t\tuniform float linewidth;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashOffset;\n\t\t\tuniform float dashSize;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\t\tvarying vec4 worldPos;\n\t\tvarying vec3 worldStart;\n\t\tvarying vec3 worldEnd;\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvarying vec2 vUv;\n\n\t\tvec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n\n\t\t\tfloat mua;\n\t\t\tfloat mub;\n\n\t\t\tvec3 p13 = p1 - p3;\n\t\t\tvec3 p43 = p4 - p3;\n\n\t\t\tvec3 p21 = p2 - p1;\n\n\t\t\tfloat d1343 = dot( p13, p43 );\n\t\t\tfloat d4321 = dot( p43, p21 );\n\t\t\tfloat d1321 = dot( p13, p21 );\n\t\t\tfloat d4343 = dot( p43, p43 );\n\t\t\tfloat d2121 = dot( p21, p21 );\n\n\t\t\tfloat denom = d2121 * d4343 - d4321 * d4321;\n\n\t\t\tfloat numer = d1343 * d4321 - d1321 * d4343;\n\n\t\t\tmua = numer / denom;\n\t\t\tmua = clamp( mua, 0.0, 1.0 );\n\t\t\tmub = ( d1343 + d4321 * ( mua ) ) / d4343;\n\t\t\tmub = clamp( mub, 0.0, 1.0 );\n\n\t\t\treturn vec2( mua, mub );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tfloat alpha = opacity;\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t// Find the closest points on the view ray and the line segment\n\t\t\t\tvec3 rayEnd = normalize( worldPos.xyz ) * 1e5;\n\t\t\t\tvec3 lineDir = worldEnd - worldStart;\n\t\t\t\tvec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );\n\n\t\t\t\tvec3 p1 = worldStart + lineDir * params.x;\n\t\t\t\tvec3 p2 = rayEnd * params.y;\n\t\t\t\tvec3 delta = p1 - p2;\n\t\t\t\tfloat len = length( delta );\n\t\t\t\tfloat norm = len / linewidth;\n\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t#ifdef ALPHA_TO_COVERAGE\n\n\t\t\t\t\t\tfloat dnorm = fwidth( norm );\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\tif ( norm > 0.5 ) {\n\n\t\t\t\t\t\t\tdiscard;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t\t#else\n\n\t\t\t\t#ifdef ALPHA_TO_COVERAGE\n\n\t\t\t\t\t// artifacts appear on some hardware if a derivative is taken within a conditional\n\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\tfloat len2 = a * a + b * b;\n\t\t\t\t\tfloat dlen = fwidth( len2 );\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t#else\n\n\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\tfloat a = vUv.x;\n\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, alpha );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, alpha );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <colorspace_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t}\n\t\t`\n};\nclass LineMaterial extends THREE$1.ShaderMaterial {\n  constructor(parameters) {\n    super({\n      type: 'LineMaterial',\n      uniforms: THREE$1.UniformsUtils.clone(THREE$1.ShaderLib['line'].uniforms),\n      vertexShader: THREE$1.ShaderLib['line'].vertexShader,\n      fragmentShader: THREE$1.ShaderLib['line'].fragmentShader,\n      clipping: true // required for clipping support\n    });\n    Object.defineProperties(this, {\n      color: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.diffuse.value;\n        },\n        set: function (value) {\n          this.uniforms.diffuse.value = value;\n        }\n      },\n      worldUnits: {\n        enumerable: true,\n        get: function () {\n          return 'WORLD_UNITS' in this.defines;\n        },\n        set: function (value) {\n          if (value === true) {\n            this.defines.WORLD_UNITS = '';\n          } else {\n            delete this.defines.WORLD_UNITS;\n          }\n        }\n      },\n      linewidth: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.linewidth.value;\n        },\n        set: function (value) {\n          this.uniforms.linewidth.value = value;\n        }\n      },\n      dashed: {\n        enumerable: true,\n        get: function () {\n          return Boolean('USE_DASH' in this.defines);\n        },\n        set(value) {\n          if (Boolean(value) !== Boolean('USE_DASH' in this.defines)) {\n            this.needsUpdate = true;\n          }\n          if (value === true) {\n            this.defines.USE_DASH = '';\n          } else {\n            delete this.defines.USE_DASH;\n          }\n        }\n      },\n      dashScale: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.dashScale.value;\n        },\n        set: function (value) {\n          this.uniforms.dashScale.value = value;\n        }\n      },\n      dashSize: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.dashSize.value;\n        },\n        set: function (value) {\n          this.uniforms.dashSize.value = value;\n        }\n      },\n      dashOffset: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.dashOffset.value;\n        },\n        set: function (value) {\n          this.uniforms.dashOffset.value = value;\n        }\n      },\n      gapSize: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.gapSize.value;\n        },\n        set: function (value) {\n          this.uniforms.gapSize.value = value;\n        }\n      },\n      opacity: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.opacity.value;\n        },\n        set: function (value) {\n          this.uniforms.opacity.value = value;\n        }\n      },\n      resolution: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.resolution.value;\n        },\n        set: function (value) {\n          this.uniforms.resolution.value.copy(value);\n        }\n      },\n      alphaToCoverage: {\n        enumerable: true,\n        get: function () {\n          return Boolean('ALPHA_TO_COVERAGE' in this.defines);\n        },\n        set: function (value) {\n          if (Boolean(value) !== Boolean('ALPHA_TO_COVERAGE' in this.defines)) {\n            this.needsUpdate = true;\n          }\n          if (value === true) {\n            this.defines.ALPHA_TO_COVERAGE = '';\n            this.extensions.derivatives = true;\n          } else {\n            delete this.defines.ALPHA_TO_COVERAGE;\n            this.extensions.derivatives = false;\n          }\n        }\n      }\n    });\n    this.setValues(parameters);\n  }\n}\nLineMaterial.prototype.isLineMaterial = true;\n\nconst THREE = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  Box3: three__WEBPACK_IMPORTED_MODULE_0__.Box3,\n  BufferGeometry: three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry,\n  InstancedInterleavedBuffer: three__WEBPACK_IMPORTED_MODULE_0__.InstancedInterleavedBuffer,\n  InterleavedBufferAttribute: three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBufferAttribute,\n  Line3: three__WEBPACK_IMPORTED_MODULE_0__.Line3,\n  MathUtils: three__WEBPACK_IMPORTED_MODULE_0__.MathUtils,\n  Matrix4: three__WEBPACK_IMPORTED_MODULE_0__.Matrix4,\n  Mesh: three__WEBPACK_IMPORTED_MODULE_0__.Mesh,\n  Sphere: three__WEBPACK_IMPORTED_MODULE_0__.Sphere,\n  Vector3: three__WEBPACK_IMPORTED_MODULE_0__.Vector3,\n  Vector4: three__WEBPACK_IMPORTED_MODULE_0__.Vector4\n};\n\n// support both modes for backwards threejs compatibility\nvar setAttributeFn = new THREE.BufferGeometry().setAttribute ? 'setAttribute' : 'addAttribute';\nconst _start = new THREE.Vector3();\nconst _end = new THREE.Vector3();\nconst _start4 = new THREE.Vector4();\nconst _end4 = new THREE.Vector4();\nconst _ssOrigin = new THREE.Vector4();\nconst _ssOrigin3 = new THREE.Vector3();\nconst _mvMatrix = new THREE.Matrix4();\nconst _line = new THREE.Line3();\nconst _closestPoint = new THREE.Vector3();\nconst _box = new THREE.Box3();\nconst _sphere = new THREE.Sphere();\nconst _clipToWorldVector = new THREE.Vector4();\nclass LineSegments2 extends THREE.Mesh {\n  constructor(geometry = new LineSegmentsGeometry(), material = new LineMaterial({\n    color: Math.random() * 0xffffff\n  })) {\n    super(geometry, material);\n    this.type = 'LineSegments2';\n  } // for backwards-compatability, but could be a method of LineSegmentsGeometry...\n\n  computeLineDistances() {\n    const geometry = this.geometry;\n    const instanceStart = geometry.attributes.instanceStart;\n    const instanceEnd = geometry.attributes.instanceEnd;\n    const lineDistances = new Float32Array(2 * instanceStart.count);\n    for (let i = 0, j = 0, l = instanceStart.count; i < l; i++, j += 2) {\n      _start.fromBufferAttribute(instanceStart, i);\n      _end.fromBufferAttribute(instanceEnd, i);\n      lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1];\n      lineDistances[j + 1] = lineDistances[j] + _start.distanceTo(_end);\n    }\n    const instanceDistanceBuffer = new THREE.InstancedInterleavedBuffer(lineDistances, 2, 1); // d0, d1\n\n    geometry[setAttributeFn]('instanceDistanceStart', new THREE.InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0)); // d0\n\n    geometry[setAttributeFn]('instanceDistanceEnd', new THREE.InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1)); // d1\n\n    return this;\n  }\n  raycast(raycaster, intersects) {\n    if (raycaster.camera === null) {\n      console.error('LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2.');\n    }\n    const threshold = raycaster.params.Line2 !== undefined ? raycaster.params.Line2.threshold || 0 : 0;\n    const ray = raycaster.ray;\n    const camera = raycaster.camera;\n    const projectionMatrix = camera.projectionMatrix;\n    const matrixWorld = this.matrixWorld;\n    const geometry = this.geometry;\n    const material = this.material;\n    const resolution = material.resolution;\n    const lineWidth = material.linewidth + threshold;\n    const instanceStart = geometry.attributes.instanceStart;\n    const instanceEnd = geometry.attributes.instanceEnd; // camera forward is negative\n\n    const near = -camera.near; // clip space is [ - 1, 1 ] so multiply by two to get the full\n    // width in clip space\n\n    const ssMaxWidth = 2.0 * Math.max(lineWidth / resolution.width, lineWidth / resolution.height); //\n    // check if we intersect the sphere bounds\n\n    if (geometry.boundingSphere === null) {\n      geometry.computeBoundingSphere();\n    }\n    _sphere.copy(geometry.boundingSphere).applyMatrix4(matrixWorld);\n    const distanceToSphere = Math.max(camera.near, _sphere.distanceToPoint(ray.origin)); // get the w component to scale the world space line width\n\n    _clipToWorldVector.set(0, 0, -distanceToSphere, 1.0).applyMatrix4(camera.projectionMatrix);\n    _clipToWorldVector.multiplyScalar(1.0 / _clipToWorldVector.w);\n    _clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse); // increase the sphere bounds by the worst case line screen space width\n\n    const sphereMargin = Math.abs(ssMaxWidth / _clipToWorldVector.w) * 0.5;\n    _sphere.radius += sphereMargin;\n    if (raycaster.ray.intersectsSphere(_sphere) === false) {\n      return;\n    } //\n    // check if we intersect the box bounds\n\n    if (geometry.boundingBox === null) {\n      geometry.computeBoundingBox();\n    }\n    _box.copy(geometry.boundingBox).applyMatrix4(matrixWorld);\n    const distanceToBox = Math.max(camera.near, _box.distanceToPoint(ray.origin)); // get the w component to scale the world space line width\n\n    _clipToWorldVector.set(0, 0, -distanceToBox, 1.0).applyMatrix4(camera.projectionMatrix);\n    _clipToWorldVector.multiplyScalar(1.0 / _clipToWorldVector.w);\n    _clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse); // increase the sphere bounds by the worst case line screen space width\n\n    const boxMargin = Math.abs(ssMaxWidth / _clipToWorldVector.w) * 0.5;\n    _box.max.x += boxMargin;\n    _box.max.y += boxMargin;\n    _box.max.z += boxMargin;\n    _box.min.x -= boxMargin;\n    _box.min.y -= boxMargin;\n    _box.min.z -= boxMargin;\n    if (raycaster.ray.intersectsBox(_box) === false) {\n      return;\n    } //\n    // pick a point 1 unit out along the ray to avoid the ray origin\n    // sitting at the camera origin which will cause \"w\" to be 0 when\n    // applying the projection matrix.\n\n    ray.at(1, _ssOrigin); // ndc space [ - 1.0, 1.0 ]\n\n    _ssOrigin.w = 1;\n    _ssOrigin.applyMatrix4(camera.matrixWorldInverse);\n    _ssOrigin.applyMatrix4(projectionMatrix);\n    _ssOrigin.multiplyScalar(1 / _ssOrigin.w); // screen space\n\n    _ssOrigin.x *= resolution.x / 2;\n    _ssOrigin.y *= resolution.y / 2;\n    _ssOrigin.z = 0;\n    _ssOrigin3.copy(_ssOrigin);\n    _mvMatrix.multiplyMatrices(camera.matrixWorldInverse, matrixWorld);\n    for (let i = 0, l = instanceStart.count; i < l; i++) {\n      _start4.fromBufferAttribute(instanceStart, i);\n      _end4.fromBufferAttribute(instanceEnd, i);\n      _start4.w = 1;\n      _end4.w = 1; // camera space\n\n      _start4.applyMatrix4(_mvMatrix);\n      _end4.applyMatrix4(_mvMatrix); // skip the segment if it's entirely behind the camera\n\n      var isBehindCameraNear = _start4.z > near && _end4.z > near;\n      if (isBehindCameraNear) {\n        continue;\n      } // trim the segment if it extends behind camera near\n\n      if (_start4.z > near) {\n        const deltaDist = _start4.z - _end4.z;\n        const t = (_start4.z - near) / deltaDist;\n        _start4.lerp(_end4, t);\n      } else if (_end4.z > near) {\n        const deltaDist = _end4.z - _start4.z;\n        const t = (_end4.z - near) / deltaDist;\n        _end4.lerp(_start4, t);\n      } // clip space\n\n      _start4.applyMatrix4(projectionMatrix);\n      _end4.applyMatrix4(projectionMatrix); // ndc space [ - 1.0, 1.0 ]\n\n      _start4.multiplyScalar(1 / _start4.w);\n      _end4.multiplyScalar(1 / _end4.w); // screen space\n\n      _start4.x *= resolution.x / 2;\n      _start4.y *= resolution.y / 2;\n      _end4.x *= resolution.x / 2;\n      _end4.y *= resolution.y / 2; // create 2d segment\n\n      _line.start.copy(_start4);\n      _line.start.z = 0;\n      _line.end.copy(_end4);\n      _line.end.z = 0; // get closest point on ray to segment\n\n      const param = _line.closestPointToPointParameter(_ssOrigin3, true);\n      _line.at(param, _closestPoint); // check if the intersection point is within clip space\n\n      const zPos = THREE.MathUtils.lerp(_start4.z, _end4.z, param);\n      const isInClipSpace = zPos >= -1 && zPos <= 1;\n      const isInside = _ssOrigin3.distanceTo(_closestPoint) < lineWidth * 0.5;\n      if (isInClipSpace && isInside) {\n        _line.start.fromBufferAttribute(instanceStart, i);\n        _line.end.fromBufferAttribute(instanceEnd, i);\n        _line.start.applyMatrix4(matrixWorld);\n        _line.end.applyMatrix4(matrixWorld);\n        const pointOnLine = new THREE.Vector3();\n        const point = new THREE.Vector3();\n        ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);\n        intersects.push({\n          point: point,\n          pointOnLine: pointOnLine,\n          distance: ray.origin.distanceTo(point),\n          object: this,\n          face: null,\n          faceIndex: i,\n          uv: null,\n          uv2: null\n        });\n      }\n    }\n  }\n}\nLineSegments2.prototype.LineSegments2 = true;\n\nclass LineGeometry extends LineSegmentsGeometry {\n  constructor() {\n    super();\n    this.type = 'LineGeometry';\n  }\n  setPositions(array) {\n    // converts [ x1, y1, z1,  x2, y2, z2, ... ] to pairs format\n    var length = array.length - 3;\n    var points = new Float32Array(2 * length);\n    for (var i = 0; i < length; i += 3) {\n      points[2 * i] = array[i];\n      points[2 * i + 1] = array[i + 1];\n      points[2 * i + 2] = array[i + 2];\n      points[2 * i + 3] = array[i + 3];\n      points[2 * i + 4] = array[i + 4];\n      points[2 * i + 5] = array[i + 5];\n    }\n    super.setPositions(points);\n    return this;\n  }\n  setColors(array) {\n    // converts [ r1, g1, b1,  r2, g2, b2, ... ] to pairs format\n    var length = array.length - 3;\n    var colors = new Float32Array(2 * length);\n    for (var i = 0; i < length; i += 3) {\n      colors[2 * i] = array[i];\n      colors[2 * i + 1] = array[i + 1];\n      colors[2 * i + 2] = array[i + 2];\n      colors[2 * i + 3] = array[i + 3];\n      colors[2 * i + 4] = array[i + 4];\n      colors[2 * i + 5] = array[i + 5];\n    }\n    super.setColors(colors);\n    return this;\n  }\n  fromLine(line) {\n    var geometry = line.geometry;\n    if (geometry.isGeometry) {\n      console.error('THREE.LineGeometry no longer supports Geometry. Use THREE.BufferGeometry instead.');\n      return;\n    } else if (geometry.isBufferGeometry) {\n      this.setPositions(geometry.attributes.position.array); // assumes non-indexed\n    } // set colors, maybe\n\n    return this;\n  }\n}\nLineGeometry.prototype.isLineGeometry = true;\n\nclass Line2 extends LineSegments2 {\n  constructor(geometry = new LineGeometry(), material = new LineMaterial({\n    color: Math.random() * 0xffffff\n  })) {\n    super(geometry, material);\n    this.type = 'Line2';\n  }\n}\nLine2.prototype.isLine2 = true;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtZmF0bGluZS9kaXN0L3RocmVlLWZhdGxpbmUubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFvUzs7QUFFcFM7QUFDQTtBQUNBLE1BQU07QUFDTixnQkFBZ0I7QUFDaEIsd0JBQXdCO0FBQ3hCLHlCQUF5QjtBQUN6Qiw0QkFBNEI7QUFDNUIsNEJBQTRCO0FBQzVCLFFBQVE7QUFDUixTQUFTO0FBQ1QsbUJBQW1CO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLHVGQUF1Rjs7QUFFdkYsMkdBQTJHOztBQUUzRyx5R0FBeUc7QUFDekc7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0Esc0ZBQXNGOztBQUV0RixxSEFBcUg7O0FBRXJILG1IQUFtSDs7QUFFbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RTs7QUFFOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sNkRBQTZEO0FBQzdELE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWCxnQkFBZ0I7QUFDaEIsYUFBYTtBQUNiLGVBQWU7QUFDZixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSx5Q0FBeUM7QUFDekMseUNBQXlDO0FBQ3pDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtEQUErRDs7QUFFL0Q7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx5REFBeUQ7O0FBRXpEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxpREFBaUQ7O0FBRWpELHFGQUFxRjs7QUFFckY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTixnQkFBZ0I7QUFDaEIsNEJBQTRCO0FBQzVCLDRCQUE0QjtBQUM1QixPQUFPO0FBQ1AsV0FBVztBQUNYLFNBQVM7QUFDVCxNQUFNO0FBQ04sUUFBUTtBQUNSLFNBQVM7QUFDVCxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELE9BQU87QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4Rjs7QUFFOUYsMkhBQTJIOztBQUUzSCx5SEFBeUg7O0FBRXpIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEOztBQUV6RCwrQkFBK0I7QUFDL0I7O0FBRUEsb0dBQW9HO0FBQ3BHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGOztBQUV6RjtBQUNBO0FBQ0EscUVBQXFFOztBQUVyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRjs7QUFFbkY7QUFDQTtBQUNBLHFFQUFxRTs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBLCtDQUErQzs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBLDRDQUE0Qzs7QUFFNUM7QUFDQSx5Q0FBeUM7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sNkRBQTZEO0FBQzdELE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWtGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC10ZXN0Ly4vbm9kZV9tb2R1bGVzL3RocmVlLWZhdGxpbmUvZGlzdC90aHJlZS1mYXRsaW5lLm1qcz80NmMwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJveDMsIEJ1ZmZlckdlb21ldHJ5LCBGbG9hdDMyQnVmZmVyQXR0cmlidXRlLCBJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSwgSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIsIEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlLCBTcGhlcmUsIFZlY3RvcjMsIFdpcmVmcmFtZUdlb21ldHJ5LCBTaGFkZXJMaWIsIFNoYWRlck1hdGVyaWFsLCBVbmlmb3Jtc0xpYiwgVW5pZm9ybXNVdGlscywgVmVjdG9yMiwgTGluZTMsIE1hdGhVdGlscywgTWF0cml4NCwgTWVzaCwgVmVjdG9yNCB9IGZyb20gJ3RocmVlJztcblxuY29uc3QgVEhSRUUkMiA9IHdpbmRvdy5USFJFRSA/IHdpbmRvdy5USFJFRSAvLyBQcmVmZXIgY29uc3VtcHRpb24gZnJvbSBnbG9iYWwgVEhSRUUsIGlmIGV4aXN0c1xuOiB7XG4gIEJveDMsXG4gIEJ1ZmZlckdlb21ldHJ5LFxuICBGbG9hdDMyQnVmZmVyQXR0cmlidXRlLFxuICBJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSxcbiAgSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIsXG4gIEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlLFxuICBTcGhlcmUsXG4gIFZlY3RvcjMsXG4gIFdpcmVmcmFtZUdlb21ldHJ5XG59O1xuXG4vLyBzdXBwb3J0IG11bHRpcGxlIG1ldGhvZCBuYW1lcyBmb3IgYmFja3dhcmRzIHRocmVlanMgY29tcGF0aWJpbGl0eVxudmFyIHNldEF0dHJpYnV0ZUZuJDEgPSBuZXcgVEhSRUUkMi5CdWZmZXJHZW9tZXRyeSgpLnNldEF0dHJpYnV0ZSA/ICdzZXRBdHRyaWJ1dGUnIDogJ2FkZEF0dHJpYnV0ZSc7XG5jb25zdCBfYm94JDEgPSBuZXcgVEhSRUUkMi5Cb3gzKCk7XG5jb25zdCBfdmVjdG9yID0gbmV3IFRIUkVFJDIuVmVjdG9yMygpO1xuY2xhc3MgTGluZVNlZ21lbnRzR2VvbWV0cnkgZXh0ZW5kcyBUSFJFRSQyLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnR5cGUgPSAnTGluZVNlZ21lbnRzR2VvbWV0cnknO1xuICAgIGNvbnN0IHBvc2l0aW9ucyA9IFstMSwgMiwgMCwgMSwgMiwgMCwgLTEsIDEsIDAsIDEsIDEsIDAsIC0xLCAwLCAwLCAxLCAwLCAwLCAtMSwgLTEsIDAsIDEsIC0xLCAwXTtcbiAgICBjb25zdCB1dnMgPSBbLTEsIDIsIDEsIDIsIC0xLCAxLCAxLCAxLCAtMSwgLTEsIDEsIC0xLCAtMSwgLTIsIDEsIC0yXTtcbiAgICBjb25zdCBpbmRleCA9IFswLCAyLCAxLCAyLCAzLCAxLCAyLCA0LCAzLCA0LCA1LCAzLCA0LCA2LCA1LCA2LCA3LCA1XTtcbiAgICB0aGlzLnNldEluZGV4KGluZGV4KTtcbiAgICB0aGlzW3NldEF0dHJpYnV0ZUZuJDFdKCdwb3NpdGlvbicsIG5ldyBUSFJFRSQyLkZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUocG9zaXRpb25zLCAzKSk7XG4gICAgdGhpc1tzZXRBdHRyaWJ1dGVGbiQxXSgndXYnLCBuZXcgVEhSRUUkMi5GbG9hdDMyQnVmZmVyQXR0cmlidXRlKHV2cywgMikpO1xuICB9XG4gIGFwcGx5TWF0cml4NChtYXRyaXgpIHtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuYXR0cmlidXRlcy5pbnN0YW5jZVN0YXJ0O1xuICAgIGNvbnN0IGVuZCA9IHRoaXMuYXR0cmlidXRlcy5pbnN0YW5jZUVuZDtcbiAgICBpZiAoc3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgc3RhcnQuYXBwbHlNYXRyaXg0KG1hdHJpeCk7XG4gICAgICBlbmQuYXBwbHlNYXRyaXg0KG1hdHJpeCk7XG4gICAgICBzdGFydC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLmJvdW5kaW5nQm94ICE9PSBudWxsKSB7XG4gICAgICB0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5ib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2V0UG9zaXRpb25zKGFycmF5KSB7XG4gICAgbGV0IGxpbmVTZWdtZW50cztcbiAgICBpZiAoYXJyYXkgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpIHtcbiAgICAgIGxpbmVTZWdtZW50cyA9IGFycmF5O1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcnJheSkpIHtcbiAgICAgIGxpbmVTZWdtZW50cyA9IG5ldyBGbG9hdDMyQXJyYXkoYXJyYXkpO1xuICAgIH1cbiAgICBjb25zdCBpbnN0YW5jZUJ1ZmZlciA9IG5ldyBUSFJFRSQyLkluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyKGxpbmVTZWdtZW50cywgNiwgMSk7IC8vIHh5eiwgeHl6XG5cbiAgICB0aGlzW3NldEF0dHJpYnV0ZUZuJDFdKCdpbnN0YW5jZVN0YXJ0JywgbmV3IFRIUkVFJDIuSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUoaW5zdGFuY2VCdWZmZXIsIDMsIDApKTsgLy8geHl6XG5cbiAgICB0aGlzW3NldEF0dHJpYnV0ZUZuJDFdKCdpbnN0YW5jZUVuZCcsIG5ldyBUSFJFRSQyLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlKGluc3RhbmNlQnVmZmVyLCAzLCAzKSk7IC8vIHh5elxuICAgIC8vXG5cbiAgICB0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpO1xuICAgIHRoaXMuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2V0Q29sb3JzKGFycmF5KSB7XG4gICAgbGV0IGNvbG9ycztcbiAgICBpZiAoYXJyYXkgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpIHtcbiAgICAgIGNvbG9ycyA9IGFycmF5O1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcnJheSkpIHtcbiAgICAgIGNvbG9ycyA9IG5ldyBGbG9hdDMyQXJyYXkoYXJyYXkpO1xuICAgIH1cbiAgICBjb25zdCBpbnN0YW5jZUNvbG9yQnVmZmVyID0gbmV3IFRIUkVFJDIuSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIoY29sb3JzLCA2LCAxKTsgLy8gcmdiLCByZ2JcblxuICAgIHRoaXNbc2V0QXR0cmlidXRlRm4kMV0oJ2luc3RhbmNlQ29sb3JTdGFydCcsIG5ldyBUSFJFRSQyLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlKGluc3RhbmNlQ29sb3JCdWZmZXIsIDMsIDApKTsgLy8gcmdiXG5cbiAgICB0aGlzW3NldEF0dHJpYnV0ZUZuJDFdKCdpbnN0YW5jZUNvbG9yRW5kJywgbmV3IFRIUkVFJDIuSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUoaW5zdGFuY2VDb2xvckJ1ZmZlciwgMywgMykpOyAvLyByZ2JcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGZyb21XaXJlZnJhbWVHZW9tZXRyeShnZW9tZXRyeSkge1xuICAgIHRoaXMuc2V0UG9zaXRpb25zKGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGZyb21FZGdlc0dlb21ldHJ5KGdlb21ldHJ5KSB7XG4gICAgdGhpcy5zZXRQb3NpdGlvbnMoZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZnJvbU1lc2gobWVzaCkge1xuICAgIHRoaXMuZnJvbVdpcmVmcmFtZUdlb21ldHJ5KG5ldyBUSFJFRSQyLldpcmVmcmFtZUdlb21ldHJ5KG1lc2guZ2VvbWV0cnkpKTsgLy8gc2V0IGNvbG9ycywgbWF5YmVcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGZyb21MaW5lU2VnbWVudHMobGluZVNlZ21lbnRzKSB7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSBsaW5lU2VnbWVudHMuZ2VvbWV0cnk7XG4gICAgaWYgKGdlb21ldHJ5LmlzR2VvbWV0cnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0xpbmVTZWdtZW50c0dlb21ldHJ5IG5vIGxvbmdlciBzdXBwb3J0cyBHZW9tZXRyeS4gVXNlIFRIUkVFLkJ1ZmZlckdlb21ldHJ5IGluc3RlYWQuJyk7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChnZW9tZXRyeS5pc0J1ZmZlckdlb21ldHJ5KSB7XG4gICAgICB0aGlzLnNldFBvc2l0aW9ucyhnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5KTsgLy8gYXNzdW1lcyBub24taW5kZXhlZFxuICAgIH0gLy8gc2V0IGNvbG9ycywgbWF5YmVcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGNvbXB1dGVCb3VuZGluZ0JveCgpIHtcbiAgICBpZiAodGhpcy5ib3VuZGluZ0JveCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5ib3VuZGluZ0JveCA9IG5ldyBUSFJFRSQyLkJveDMoKTtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLmF0dHJpYnV0ZXMuaW5zdGFuY2VTdGFydDtcbiAgICBjb25zdCBlbmQgPSB0aGlzLmF0dHJpYnV0ZXMuaW5zdGFuY2VFbmQ7XG4gICAgaWYgKHN0YXJ0ICE9PSB1bmRlZmluZWQgJiYgZW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3guc2V0RnJvbUJ1ZmZlckF0dHJpYnV0ZShzdGFydCk7XG4gICAgICBfYm94JDEuc2V0RnJvbUJ1ZmZlckF0dHJpYnV0ZShlbmQpO1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC51bmlvbihfYm94JDEpO1xuICAgIH1cbiAgfVxuICBjb21wdXRlQm91bmRpbmdTcGhlcmUoKSB7XG4gICAgaWYgKHRoaXMuYm91bmRpbmdTcGhlcmUgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgVEhSRUUkMi5TcGhlcmUoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYm91bmRpbmdCb3ggPT09IG51bGwpIHtcbiAgICAgIHRoaXMuY29tcHV0ZUJvdW5kaW5nQm94KCk7XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5hdHRyaWJ1dGVzLmluc3RhbmNlU3RhcnQ7XG4gICAgY29uc3QgZW5kID0gdGhpcy5hdHRyaWJ1dGVzLmluc3RhbmNlRW5kO1xuICAgIGlmIChzdGFydCAhPT0gdW5kZWZpbmVkICYmIGVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBjZW50ZXIgPSB0aGlzLmJvdW5kaW5nU3BoZXJlLmNlbnRlcjtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3guZ2V0Q2VudGVyKGNlbnRlcik7XG4gICAgICBsZXQgbWF4UmFkaXVzU3EgPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlsID0gc3RhcnQuY291bnQ7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIF92ZWN0b3IuZnJvbUJ1ZmZlckF0dHJpYnV0ZShzdGFydCwgaSk7XG4gICAgICAgIG1heFJhZGl1c1NxID0gTWF0aC5tYXgobWF4UmFkaXVzU3EsIGNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZChfdmVjdG9yKSk7XG4gICAgICAgIF92ZWN0b3IuZnJvbUJ1ZmZlckF0dHJpYnV0ZShlbmQsIGkpO1xuICAgICAgICBtYXhSYWRpdXNTcSA9IE1hdGgubWF4KG1heFJhZGl1c1NxLCBjZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoX3ZlY3RvcikpO1xuICAgICAgfVxuICAgICAgdGhpcy5ib3VuZGluZ1NwaGVyZS5yYWRpdXMgPSBNYXRoLnNxcnQobWF4UmFkaXVzU3EpO1xuICAgICAgaWYgKGlzTmFOKHRoaXMuYm91bmRpbmdTcGhlcmUucmFkaXVzKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdUSFJFRS5MaW5lU2VnbWVudHNHZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTogQ29tcHV0ZWQgcmFkaXVzIGlzIE5hTi4gVGhlIGluc3RhbmNlZCBwb3NpdGlvbiBkYXRhIGlzIGxpa2VseSB0byBoYXZlIE5hTiB2YWx1ZXMuJywgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHRvSlNPTigpIHsvLyB0b2RvXG4gIH1cbiAgYXBwbHlNYXRyaXgobWF0cml4KSB7XG4gICAgY29uc29sZS53YXJuKCdUSFJFRS5MaW5lU2VnbWVudHNHZW9tZXRyeTogYXBwbHlNYXRyaXgoKSBoYXMgYmVlbiByZW5hbWVkIHRvIGFwcGx5TWF0cml4NCgpLicpO1xuICAgIHJldHVybiB0aGlzLmFwcGx5TWF0cml4NChtYXRyaXgpO1xuICB9XG59XG5MaW5lU2VnbWVudHNHZW9tZXRyeS5wcm90b3R5cGUuaXNMaW5lU2VnbWVudHNHZW9tZXRyeSA9IHRydWU7XG5cbi8qKlxuICogcGFyYW1ldGVycyA9IHtcbiAqICBjb2xvcjogPGhleD4sXG4gKiAgbGluZXdpZHRoOiA8ZmxvYXQ+LFxuICogIGRhc2hlZDogPGJvb2xlYW4+LFxuICogIGRhc2hTY2FsZTogPGZsb2F0PixcbiAqICBkYXNoU2l6ZTogPGZsb2F0PixcbiAqICBkYXNoT2Zmc2V0OiA8ZmxvYXQ+LFxuICogIGdhcFNpemU6IDxmbG9hdD4sXG4gKiAgcmVzb2x1dGlvbjogPFZlY3RvcjI+LCAvLyB0byBiZSBzZXQgYnkgcmVuZGVyZXJcbiAqIH1cbiAqL1xuXG5jb25zdCBUSFJFRSQxID0gd2luZG93LlRIUkVFID8gd2luZG93LlRIUkVFIC8vIFByZWZlciBjb25zdW1wdGlvbiBmcm9tIGdsb2JhbCBUSFJFRSwgaWYgZXhpc3RzXG46IHtcbiAgU2hhZGVyTGliLFxuICBTaGFkZXJNYXRlcmlhbCxcbiAgVW5pZm9ybXNMaWIsXG4gIFVuaWZvcm1zVXRpbHMsXG4gIFZlY3RvcjJcbn07XG5USFJFRSQxLlVuaWZvcm1zTGliLmxpbmUgPSB7XG4gIHdvcmxkVW5pdHM6IHtcbiAgICB2YWx1ZTogMVxuICB9LFxuICBsaW5ld2lkdGg6IHtcbiAgICB2YWx1ZTogMVxuICB9LFxuICByZXNvbHV0aW9uOiB7XG4gICAgdmFsdWU6IG5ldyBUSFJFRSQxLlZlY3RvcjIoMSwgMSlcbiAgfSxcbiAgZGFzaFNjYWxlOiB7XG4gICAgdmFsdWU6IDFcbiAgfSxcbiAgZGFzaFNpemU6IHtcbiAgICB2YWx1ZTogMVxuICB9LFxuICBkYXNoT2Zmc2V0OiB7XG4gICAgdmFsdWU6IDBcbiAgfSxcbiAgZ2FwU2l6ZToge1xuICAgIHZhbHVlOiAxXG4gIH0gLy8gdG9kbyBGSVggLSBtYXliZSBjaGFuZ2UgdG8gdG90YWxTaXplXG59O1xuVEhSRUUkMS5TaGFkZXJMaWJbJ2xpbmUnXSA9IHtcbiAgdW5pZm9ybXM6IFRIUkVFJDEuVW5pZm9ybXNVdGlscy5tZXJnZShbVEhSRUUkMS5Vbmlmb3Jtc0xpYi5jb21tb24sIFRIUkVFJDEuVW5pZm9ybXNMaWIuZm9nLCBUSFJFRSQxLlVuaWZvcm1zTGliLmxpbmVdKSxcbiAgdmVydGV4U2hhZGVyOiAvKiBnbHNsICovXG4gIGBcblx0XHQjaW5jbHVkZSA8Y29tbW9uPlxuXHRcdCNpbmNsdWRlIDxjb2xvcl9wYXJzX3ZlcnRleD5cblx0XHQjaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PlxuXHRcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cblx0XHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxuXG5cdFx0dW5pZm9ybSBmbG9hdCBsaW5ld2lkdGg7XG5cdFx0dW5pZm9ybSB2ZWMyIHJlc29sdXRpb247XG5cblx0XHRhdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZVN0YXJ0O1xuXHRcdGF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlRW5kO1xuXG5cdFx0YXR0cmlidXRlIHZlYzMgaW5zdGFuY2VDb2xvclN0YXJ0O1xuXHRcdGF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlQ29sb3JFbmQ7XG5cblx0XHR2YXJ5aW5nIHZlYzIgdlV2O1xuXHRcdHZhcnlpbmcgdmVjNCB3b3JsZFBvcztcblx0XHR2YXJ5aW5nIHZlYzMgd29ybGRTdGFydDtcblx0XHR2YXJ5aW5nIHZlYzMgd29ybGRFbmQ7XG5cblx0XHQjaWZkZWYgVVNFX0RBU0hcblxuXHRcdFx0dW5pZm9ybSBmbG9hdCBkYXNoU2NhbGU7XG5cdFx0XHRhdHRyaWJ1dGUgZmxvYXQgaW5zdGFuY2VEaXN0YW5jZVN0YXJ0O1xuXHRcdFx0YXR0cmlidXRlIGZsb2F0IGluc3RhbmNlRGlzdGFuY2VFbmQ7XG5cdFx0XHR2YXJ5aW5nIGZsb2F0IHZMaW5lRGlzdGFuY2U7XG5cblx0XHQjZW5kaWZcblxuXHRcdHZvaWQgdHJpbVNlZ21lbnQoIGNvbnN0IGluIHZlYzQgc3RhcnQsIGlub3V0IHZlYzQgZW5kICkge1xuXG5cdFx0XHQvLyB0cmltIGVuZCBzZWdtZW50IHNvIGl0IHRlcm1pbmF0ZXMgYmV0d2VlbiB0aGUgY2FtZXJhIHBsYW5lIGFuZCB0aGUgbmVhciBwbGFuZVxuXG5cdFx0XHQvLyBjb25zZXJ2YXRpdmUgZXN0aW1hdGUgb2YgdGhlIG5lYXIgcGxhbmVcblx0XHRcdGZsb2F0IGEgPSBwcm9qZWN0aW9uTWF0cml4WyAyIF1bIDIgXTsgLy8gM25kIGVudHJ5IGluIDN0aCBjb2x1bW5cblx0XHRcdGZsb2F0IGIgPSBwcm9qZWN0aW9uTWF0cml4WyAzIF1bIDIgXTsgLy8gM25kIGVudHJ5IGluIDR0aCBjb2x1bW5cblx0XHRcdGZsb2F0IG5lYXJFc3RpbWF0ZSA9IC0gMC41ICogYiAvIGE7XG5cblx0XHRcdGZsb2F0IGFscGhhID0gKCBuZWFyRXN0aW1hdGUgLSBzdGFydC56ICkgLyAoIGVuZC56IC0gc3RhcnQueiApO1xuXG5cdFx0XHRlbmQueHl6ID0gbWl4KCBzdGFydC54eXosIGVuZC54eXosIGFscGhhICk7XG5cblx0XHR9XG5cblx0XHR2b2lkIG1haW4oKSB7XG5cblx0XHRcdCNpZmRlZiBVU0VfQ09MT1JcblxuXHRcdFx0XHR2Q29sb3IueHl6ID0gKCBwb3NpdGlvbi55IDwgMC41ICkgPyBpbnN0YW5jZUNvbG9yU3RhcnQgOiBpbnN0YW5jZUNvbG9yRW5kO1xuXG5cdFx0XHQjZW5kaWZcblxuXHRcdFx0I2lmZGVmIFVTRV9EQVNIXG5cblx0XHRcdFx0dkxpbmVEaXN0YW5jZSA9ICggcG9zaXRpb24ueSA8IDAuNSApID8gZGFzaFNjYWxlICogaW5zdGFuY2VEaXN0YW5jZVN0YXJ0IDogZGFzaFNjYWxlICogaW5zdGFuY2VEaXN0YW5jZUVuZDtcblxuXHRcdFx0I2VuZGlmXG5cblx0XHRcdGZsb2F0IGFzcGVjdCA9IHJlc29sdXRpb24ueCAvIHJlc29sdXRpb24ueTtcblxuXHRcdFx0dlV2ID0gdXY7XG5cblx0XHRcdC8vIGNhbWVyYSBzcGFjZVxuXHRcdFx0dmVjNCBzdGFydCA9IG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIGluc3RhbmNlU3RhcnQsIDEuMCApO1xuXHRcdFx0dmVjNCBlbmQgPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBpbnN0YW5jZUVuZCwgMS4wICk7XG5cblx0XHRcdHdvcmxkU3RhcnQgPSBzdGFydC54eXo7XG5cdFx0XHR3b3JsZEVuZCA9IGVuZC54eXo7XG5cblx0XHRcdC8vIHNwZWNpYWwgY2FzZSBmb3IgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiwgYW5kIHNlZ21lbnRzIHRoYXQgdGVybWluYXRlIGVpdGhlciBpbiwgb3IgYmVoaW5kLCB0aGUgY2FtZXJhIHBsYW5lXG5cdFx0XHQvLyBjbGVhcmx5IHRoZSBncHUgZmlybXdhcmUgaGFzIGEgd2F5IG9mIGFkZHJlc3NpbmcgdGhpcyBpc3N1ZSB3aGVuIHByb2plY3RpbmcgaW50byBuZGMgc3BhY2Vcblx0XHRcdC8vIGJ1dCB3ZSBuZWVkIHRvIHBlcmZvcm0gbmRjLXNwYWNlIGNhbGN1bGF0aW9ucyBpbiB0aGUgc2hhZGVyLCBzbyB3ZSBtdXN0IGFkZHJlc3MgdGhpcyBpc3N1ZSBkaXJlY3RseVxuXHRcdFx0Ly8gcGVyaGFwcyB0aGVyZSBpcyBhIG1vcmUgZWxlZ2FudCBzb2x1dGlvbiAtLSBXZXN0TGFuZ2xleVxuXG5cdFx0XHRib29sIHBlcnNwZWN0aXZlID0gKCBwcm9qZWN0aW9uTWF0cml4WyAyIF1bIDMgXSA9PSAtIDEuMCApOyAvLyA0dGggZW50cnkgaW4gdGhlIDNyZCBjb2x1bW5cblxuXHRcdFx0aWYgKCBwZXJzcGVjdGl2ZSApIHtcblxuXHRcdFx0XHRpZiAoIHN0YXJ0LnogPCAwLjAgJiYgZW5kLnogPj0gMC4wICkge1xuXG5cdFx0XHRcdFx0dHJpbVNlZ21lbnQoIHN0YXJ0LCBlbmQgKTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBlbmQueiA8IDAuMCAmJiBzdGFydC56ID49IDAuMCApIHtcblxuXHRcdFx0XHRcdHRyaW1TZWdtZW50KCBlbmQsIHN0YXJ0ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGNsaXAgc3BhY2Vcblx0XHRcdHZlYzQgY2xpcFN0YXJ0ID0gcHJvamVjdGlvbk1hdHJpeCAqIHN0YXJ0O1xuXHRcdFx0dmVjNCBjbGlwRW5kID0gcHJvamVjdGlvbk1hdHJpeCAqIGVuZDtcblxuXHRcdFx0Ly8gbmRjIHNwYWNlXG5cdFx0XHR2ZWMzIG5kY1N0YXJ0ID0gY2xpcFN0YXJ0Lnh5eiAvIGNsaXBTdGFydC53O1xuXHRcdFx0dmVjMyBuZGNFbmQgPSBjbGlwRW5kLnh5eiAvIGNsaXBFbmQudztcblxuXHRcdFx0Ly8gZGlyZWN0aW9uXG5cdFx0XHR2ZWMyIGRpciA9IG5kY0VuZC54eSAtIG5kY1N0YXJ0Lnh5O1xuXG5cdFx0XHQvLyBhY2NvdW50IGZvciBjbGlwLXNwYWNlIGFzcGVjdCByYXRpb1xuXHRcdFx0ZGlyLnggKj0gYXNwZWN0O1xuXHRcdFx0ZGlyID0gbm9ybWFsaXplKCBkaXIgKTtcblxuXHRcdFx0I2lmZGVmIFdPUkxEX1VOSVRTXG5cblx0XHRcdFx0Ly8gZ2V0IHRoZSBvZmZzZXQgZGlyZWN0aW9uIGFzIHBlcnBlbmRpY3VsYXIgdG8gdGhlIHZpZXcgdmVjdG9yXG5cdFx0XHRcdHZlYzMgd29ybGREaXIgPSBub3JtYWxpemUoIGVuZC54eXogLSBzdGFydC54eXogKTtcblx0XHRcdFx0dmVjMyBvZmZzZXQ7XG5cdFx0XHRcdGlmICggcG9zaXRpb24ueSA8IDAuNSApIHtcblxuXHRcdFx0XHRcdG9mZnNldCA9IG5vcm1hbGl6ZSggY3Jvc3MoIHN0YXJ0Lnh5eiwgd29ybGREaXIgKSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRvZmZzZXQgPSBub3JtYWxpemUoIGNyb3NzKCBlbmQueHl6LCB3b3JsZERpciApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHNpZ24gZmxpcFxuXHRcdFx0XHRpZiAoIHBvc2l0aW9uLnggPCAwLjAgKSBvZmZzZXQgKj0gLSAxLjA7XG5cblx0XHRcdFx0ZmxvYXQgZm9yd2FyZE9mZnNldCA9IGRvdCggd29ybGREaXIsIHZlYzMoIDAuMCwgMC4wLCAxLjAgKSApO1xuXG5cdFx0XHRcdC8vIGRvbid0IGV4dGVuZCB0aGUgbGluZSBpZiB3ZSdyZSByZW5kZXJpbmcgZGFzaGVzIGJlY2F1c2Ugd2Vcblx0XHRcdFx0Ly8gd29uJ3QgYmUgcmVuZGVyaW5nIHRoZSBlbmRjYXBzXG5cdFx0XHRcdCNpZm5kZWYgVVNFX0RBU0hcblxuXHRcdFx0XHRcdC8vIGV4dGVuZCB0aGUgbGluZSBib3VuZHMgdG8gZW5jb21wYXNzICBlbmRjYXBzXG5cdFx0XHRcdFx0c3RhcnQueHl6ICs9IC0gd29ybGREaXIgKiBsaW5ld2lkdGggKiAwLjU7XG5cdFx0XHRcdFx0ZW5kLnh5eiArPSB3b3JsZERpciAqIGxpbmV3aWR0aCAqIDAuNTtcblxuXHRcdFx0XHRcdC8vIHNoaWZ0IHRoZSBwb3NpdGlvbiBvZiB0aGUgcXVhZCBzbyBpdCBodWdzIHRoZSBmb3J3YXJkIGVkZ2Ugb2YgdGhlIGxpbmVcblx0XHRcdFx0XHRvZmZzZXQueHkgLT0gZGlyICogZm9yd2FyZE9mZnNldDtcblx0XHRcdFx0XHRvZmZzZXQueiArPSAwLjU7XG5cblx0XHRcdFx0I2VuZGlmXG5cblx0XHRcdFx0Ly8gZW5kY2Fwc1xuXHRcdFx0XHRpZiAoIHBvc2l0aW9uLnkgPiAxLjAgfHwgcG9zaXRpb24ueSA8IDAuMCApIHtcblxuXHRcdFx0XHRcdG9mZnNldC54eSArPSBkaXIgKiAyLjAgKiBmb3J3YXJkT2Zmc2V0O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBhZGp1c3QgZm9yIGxpbmV3aWR0aFxuXHRcdFx0XHRvZmZzZXQgKj0gbGluZXdpZHRoICogMC41O1xuXG5cdFx0XHRcdC8vIHNldCB0aGUgd29ybGQgcG9zaXRpb25cblx0XHRcdFx0d29ybGRQb3MgPSAoIHBvc2l0aW9uLnkgPCAwLjUgKSA/IHN0YXJ0IDogZW5kO1xuXHRcdFx0XHR3b3JsZFBvcy54eXogKz0gb2Zmc2V0O1xuXG5cdFx0XHRcdC8vIHByb2plY3QgdGhlIHdvcmxkcG9zXG5cdFx0XHRcdHZlYzQgY2xpcCA9IHByb2plY3Rpb25NYXRyaXggKiB3b3JsZFBvcztcblxuXHRcdFx0XHQvLyBzaGlmdCB0aGUgZGVwdGggb2YgdGhlIHByb2plY3RlZCBwb2ludHMgc28gdGhlIGxpbmVcblx0XHRcdFx0Ly8gc2VnZW1lbnRzIG92ZXJsYXAgbmVhdGx5XG5cdFx0XHRcdHZlYzMgY2xpcFBvc2UgPSAoIHBvc2l0aW9uLnkgPCAwLjUgKSA/IG5kY1N0YXJ0IDogbmRjRW5kO1xuXHRcdFx0XHRjbGlwLnogPSBjbGlwUG9zZS56ICogY2xpcC53O1xuXG5cdFx0XHQjZWxzZVxuXG5cdFx0XHR2ZWMyIG9mZnNldCA9IHZlYzIoIGRpci55LCAtIGRpci54ICk7XG5cdFx0XHQvLyB1bmRvIGFzcGVjdCByYXRpbyBhZGp1c3RtZW50XG5cdFx0XHRkaXIueCAvPSBhc3BlY3Q7XG5cdFx0XHRvZmZzZXQueCAvPSBhc3BlY3Q7XG5cblx0XHRcdC8vIHNpZ24gZmxpcFxuXHRcdFx0aWYgKCBwb3NpdGlvbi54IDwgMC4wICkgb2Zmc2V0ICo9IC0gMS4wO1xuXG5cdFx0XHQvLyBlbmRjYXBzXG5cdFx0XHRpZiAoIHBvc2l0aW9uLnkgPCAwLjAgKSB7XG5cblx0XHRcdFx0b2Zmc2V0ICs9IC0gZGlyO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBwb3NpdGlvbi55ID4gMS4wICkge1xuXG5cdFx0XHRcdG9mZnNldCArPSBkaXI7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gYWRqdXN0IGZvciBsaW5ld2lkdGhcblx0XHRcdG9mZnNldCAqPSBsaW5ld2lkdGg7XG5cblx0XHRcdC8vIGFkanVzdCBmb3IgY2xpcC1zcGFjZSB0byBzY3JlZW4tc3BhY2UgY29udmVyc2lvbiAvLyBtYXliZSByZXNvbHV0aW9uIHNob3VsZCBiZSBiYXNlZCBvbiB2aWV3cG9ydCAuLi5cblx0XHRcdG9mZnNldCAvPSByZXNvbHV0aW9uLnk7XG5cblx0XHRcdC8vIHNlbGVjdCBlbmRcblx0XHRcdHZlYzQgY2xpcCA9ICggcG9zaXRpb24ueSA8IDAuNSApID8gY2xpcFN0YXJ0IDogY2xpcEVuZDtcblxuXHRcdFx0Ly8gYmFjayB0byBjbGlwIHNwYWNlXG5cdFx0XHRvZmZzZXQgKj0gY2xpcC53O1xuXG5cdFx0XHRjbGlwLnh5ICs9IG9mZnNldDtcblxuXHRcdFx0I2VuZGlmXG5cblx0XHRcdGdsX1Bvc2l0aW9uID0gY2xpcDtcblxuXHRcdFx0dmVjNCBtdlBvc2l0aW9uID0gKCBwb3NpdGlvbi55IDwgMC41ICkgPyBzdGFydCA6IGVuZDsgLy8gdGhpcyBpcyBhbiBhcHByb3hpbWF0aW9uXG5cblx0XHRcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XG5cdFx0XHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cblx0XHRcdCNpbmNsdWRlIDxmb2dfdmVydGV4PlxuXG5cdFx0fVxuXHRcdGAsXG4gIGZyYWdtZW50U2hhZGVyOiAvKiBnbHNsICovXG4gIGBcblx0XHR1bmlmb3JtIHZlYzMgZGlmZnVzZTtcblx0XHR1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XG5cdFx0dW5pZm9ybSBmbG9hdCBsaW5ld2lkdGg7XG5cblx0XHQjaWZkZWYgVVNFX0RBU0hcblxuXHRcdFx0dW5pZm9ybSBmbG9hdCBkYXNoT2Zmc2V0O1xuXHRcdFx0dW5pZm9ybSBmbG9hdCBkYXNoU2l6ZTtcblx0XHRcdHVuaWZvcm0gZmxvYXQgZ2FwU2l6ZTtcblxuXHRcdCNlbmRpZlxuXG5cdFx0dmFyeWluZyBmbG9hdCB2TGluZURpc3RhbmNlO1xuXHRcdHZhcnlpbmcgdmVjNCB3b3JsZFBvcztcblx0XHR2YXJ5aW5nIHZlYzMgd29ybGRTdGFydDtcblx0XHR2YXJ5aW5nIHZlYzMgd29ybGRFbmQ7XG5cblx0XHQjaW5jbHVkZSA8Y29tbW9uPlxuXHRcdCNpbmNsdWRlIDxjb2xvcl9wYXJzX2ZyYWdtZW50PlxuXHRcdCNpbmNsdWRlIDxmb2dfcGFyc19mcmFnbWVudD5cblx0XHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cblx0XHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XG5cblx0XHR2YXJ5aW5nIHZlYzIgdlV2O1xuXG5cdFx0dmVjMiBjbG9zZXN0TGluZVRvTGluZSh2ZWMzIHAxLCB2ZWMzIHAyLCB2ZWMzIHAzLCB2ZWMzIHA0KSB7XG5cblx0XHRcdGZsb2F0IG11YTtcblx0XHRcdGZsb2F0IG11YjtcblxuXHRcdFx0dmVjMyBwMTMgPSBwMSAtIHAzO1xuXHRcdFx0dmVjMyBwNDMgPSBwNCAtIHAzO1xuXG5cdFx0XHR2ZWMzIHAyMSA9IHAyIC0gcDE7XG5cblx0XHRcdGZsb2F0IGQxMzQzID0gZG90KCBwMTMsIHA0MyApO1xuXHRcdFx0ZmxvYXQgZDQzMjEgPSBkb3QoIHA0MywgcDIxICk7XG5cdFx0XHRmbG9hdCBkMTMyMSA9IGRvdCggcDEzLCBwMjEgKTtcblx0XHRcdGZsb2F0IGQ0MzQzID0gZG90KCBwNDMsIHA0MyApO1xuXHRcdFx0ZmxvYXQgZDIxMjEgPSBkb3QoIHAyMSwgcDIxICk7XG5cblx0XHRcdGZsb2F0IGRlbm9tID0gZDIxMjEgKiBkNDM0MyAtIGQ0MzIxICogZDQzMjE7XG5cblx0XHRcdGZsb2F0IG51bWVyID0gZDEzNDMgKiBkNDMyMSAtIGQxMzIxICogZDQzNDM7XG5cblx0XHRcdG11YSA9IG51bWVyIC8gZGVub207XG5cdFx0XHRtdWEgPSBjbGFtcCggbXVhLCAwLjAsIDEuMCApO1xuXHRcdFx0bXViID0gKCBkMTM0MyArIGQ0MzIxICogKCBtdWEgKSApIC8gZDQzNDM7XG5cdFx0XHRtdWIgPSBjbGFtcCggbXViLCAwLjAsIDEuMCApO1xuXG5cdFx0XHRyZXR1cm4gdmVjMiggbXVhLCBtdWIgKTtcblxuXHRcdH1cblxuXHRcdHZvaWQgbWFpbigpIHtcblxuXHRcdFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD5cblxuXHRcdFx0I2lmZGVmIFVTRV9EQVNIXG5cblx0XHRcdFx0aWYgKCB2VXYueSA8IC0gMS4wIHx8IHZVdi55ID4gMS4wICkgZGlzY2FyZDsgLy8gZGlzY2FyZCBlbmRjYXBzXG5cblx0XHRcdFx0aWYgKCBtb2QoIHZMaW5lRGlzdGFuY2UgKyBkYXNoT2Zmc2V0LCBkYXNoU2l6ZSArIGdhcFNpemUgKSA+IGRhc2hTaXplICkgZGlzY2FyZDsgLy8gdG9kbyAtIEZJWFxuXG5cdFx0XHQjZW5kaWZcblxuXHRcdFx0ZmxvYXQgYWxwaGEgPSBvcGFjaXR5O1xuXG5cdFx0XHQjaWZkZWYgV09STERfVU5JVFNcblxuXHRcdFx0XHQvLyBGaW5kIHRoZSBjbG9zZXN0IHBvaW50cyBvbiB0aGUgdmlldyByYXkgYW5kIHRoZSBsaW5lIHNlZ21lbnRcblx0XHRcdFx0dmVjMyByYXlFbmQgPSBub3JtYWxpemUoIHdvcmxkUG9zLnh5eiApICogMWU1O1xuXHRcdFx0XHR2ZWMzIGxpbmVEaXIgPSB3b3JsZEVuZCAtIHdvcmxkU3RhcnQ7XG5cdFx0XHRcdHZlYzIgcGFyYW1zID0gY2xvc2VzdExpbmVUb0xpbmUoIHdvcmxkU3RhcnQsIHdvcmxkRW5kLCB2ZWMzKCAwLjAsIDAuMCwgMC4wICksIHJheUVuZCApO1xuXG5cdFx0XHRcdHZlYzMgcDEgPSB3b3JsZFN0YXJ0ICsgbGluZURpciAqIHBhcmFtcy54O1xuXHRcdFx0XHR2ZWMzIHAyID0gcmF5RW5kICogcGFyYW1zLnk7XG5cdFx0XHRcdHZlYzMgZGVsdGEgPSBwMSAtIHAyO1xuXHRcdFx0XHRmbG9hdCBsZW4gPSBsZW5ndGgoIGRlbHRhICk7XG5cdFx0XHRcdGZsb2F0IG5vcm0gPSBsZW4gLyBsaW5ld2lkdGg7XG5cblx0XHRcdFx0I2lmbmRlZiBVU0VfREFTSFxuXG5cdFx0XHRcdFx0I2lmZGVmIEFMUEhBX1RPX0NPVkVSQUdFXG5cblx0XHRcdFx0XHRcdGZsb2F0IGRub3JtID0gZndpZHRoKCBub3JtICk7XG5cdFx0XHRcdFx0XHRhbHBoYSA9IDEuMCAtIHNtb290aHN0ZXAoIDAuNSAtIGRub3JtLCAwLjUgKyBkbm9ybSwgbm9ybSApO1xuXG5cdFx0XHRcdFx0I2Vsc2VcblxuXHRcdFx0XHRcdFx0aWYgKCBub3JtID4gMC41ICkge1xuXG5cdFx0XHRcdFx0XHRcdGRpc2NhcmQ7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdCNlbmRpZlxuXG5cdFx0XHQjZW5kaWZcblxuXHRcdFx0I2Vsc2VcblxuXHRcdFx0XHQjaWZkZWYgQUxQSEFfVE9fQ09WRVJBR0VcblxuXHRcdFx0XHRcdC8vIGFydGlmYWN0cyBhcHBlYXIgb24gc29tZSBoYXJkd2FyZSBpZiBhIGRlcml2YXRpdmUgaXMgdGFrZW4gd2l0aGluIGEgY29uZGl0aW9uYWxcblx0XHRcdFx0XHRmbG9hdCBhID0gdlV2Lng7XG5cdFx0XHRcdFx0ZmxvYXQgYiA9ICggdlV2LnkgPiAwLjAgKSA/IHZVdi55IC0gMS4wIDogdlV2LnkgKyAxLjA7XG5cdFx0XHRcdFx0ZmxvYXQgbGVuMiA9IGEgKiBhICsgYiAqIGI7XG5cdFx0XHRcdFx0ZmxvYXQgZGxlbiA9IGZ3aWR0aCggbGVuMiApO1xuXG5cdFx0XHRcdFx0aWYgKCBhYnMoIHZVdi55ICkgPiAxLjAgKSB7XG5cblx0XHRcdFx0XHRcdGFscGhhID0gMS4wIC0gc21vb3Roc3RlcCggMS4wIC0gZGxlbiwgMS4wICsgZGxlbiwgbGVuMiApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdCNlbHNlXG5cblx0XHRcdGlmICggYWJzKCB2VXYueSApID4gMS4wICkge1xuXG5cdFx0XHRcdGZsb2F0IGEgPSB2VXYueDtcblx0XHRcdFx0ZmxvYXQgYiA9ICggdlV2LnkgPiAwLjAgKSA/IHZVdi55IC0gMS4wIDogdlV2LnkgKyAxLjA7XG5cdFx0XHRcdGZsb2F0IGxlbjIgPSBhICogYSArIGIgKiBiO1xuXG5cdFx0XHRcdGlmICggbGVuMiA+IDEuMCApIGRpc2NhcmQ7XG5cblx0XHRcdH1cblxuXHRcdFx0XHQjZW5kaWZcblxuXHRcdFx0I2VuZGlmXG5cblx0XHRcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgYWxwaGEgKTtcblxuXHRcdFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxuXHRcdFx0I2luY2x1ZGUgPGNvbG9yX2ZyYWdtZW50PlxuXG5cdFx0XHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBkaWZmdXNlQ29sb3IucmdiLCBhbHBoYSApO1xuXG5cdFx0XHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XG5cdFx0XHQjaW5jbHVkZSA8Y29sb3JzcGFjZV9mcmFnbWVudD5cblx0XHRcdCNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+XG5cdFx0XHQjaW5jbHVkZSA8cHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudD5cblxuXHRcdH1cblx0XHRgXG59O1xuY2xhc3MgTGluZU1hdGVyaWFsIGV4dGVuZHMgVEhSRUUkMS5TaGFkZXJNYXRlcmlhbCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcih7XG4gICAgICB0eXBlOiAnTGluZU1hdGVyaWFsJyxcbiAgICAgIHVuaWZvcm1zOiBUSFJFRSQxLlVuaWZvcm1zVXRpbHMuY2xvbmUoVEhSRUUkMS5TaGFkZXJMaWJbJ2xpbmUnXS51bmlmb3JtcyksXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IFRIUkVFJDEuU2hhZGVyTGliWydsaW5lJ10udmVydGV4U2hhZGVyLFxuICAgICAgZnJhZ21lbnRTaGFkZXI6IFRIUkVFJDEuU2hhZGVyTGliWydsaW5lJ10uZnJhZ21lbnRTaGFkZXIsXG4gICAgICBjbGlwcGluZzogdHJ1ZSAvLyByZXF1aXJlZCBmb3IgY2xpcHBpbmcgc3VwcG9ydFxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgIGNvbG9yOiB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmRpZmZ1c2UudmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgdGhpcy51bmlmb3Jtcy5kaWZmdXNlLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB3b3JsZFVuaXRzOiB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiAnV09STERfVU5JVFMnIGluIHRoaXMuZGVmaW5lcztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICBpZiAodmFsdWUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuZGVmaW5lcy5XT1JMRF9VTklUUyA9ICcnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5kZWZpbmVzLldPUkxEX1VOSVRTO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGxpbmV3aWR0aDoge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5saW5ld2lkdGgudmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgdGhpcy51bmlmb3Jtcy5saW5ld2lkdGgudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRhc2hlZDoge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gQm9vbGVhbignVVNFX0RBU0gnIGluIHRoaXMuZGVmaW5lcyk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgIGlmIChCb29sZWFuKHZhbHVlKSAhPT0gQm9vbGVhbignVVNFX0RBU0gnIGluIHRoaXMuZGVmaW5lcykpIHtcbiAgICAgICAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsdWUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuZGVmaW5lcy5VU0VfREFTSCA9ICcnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5kZWZpbmVzLlVTRV9EQVNIO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRhc2hTY2FsZToge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5kYXNoU2NhbGUudmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgdGhpcy51bmlmb3Jtcy5kYXNoU2NhbGUudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRhc2hTaXplOiB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmRhc2hTaXplLnZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHRoaXMudW5pZm9ybXMuZGFzaFNpemUudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRhc2hPZmZzZXQ6IHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZGFzaE9mZnNldC52YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB0aGlzLnVuaWZvcm1zLmRhc2hPZmZzZXQudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGdhcFNpemU6IHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZ2FwU2l6ZS52YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB0aGlzLnVuaWZvcm1zLmdhcFNpemUudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9wYWNpdHk6IHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMub3BhY2l0eS52YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB0aGlzLnVuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlc29sdXRpb246IHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMucmVzb2x1dGlvbi52YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB0aGlzLnVuaWZvcm1zLnJlc29sdXRpb24udmFsdWUuY29weSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhbHBoYVRvQ292ZXJhZ2U6IHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIEJvb2xlYW4oJ0FMUEhBX1RPX0NPVkVSQUdFJyBpbiB0aGlzLmRlZmluZXMpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIGlmIChCb29sZWFuKHZhbHVlKSAhPT0gQm9vbGVhbignQUxQSEFfVE9fQ09WRVJBR0UnIGluIHRoaXMuZGVmaW5lcykpIHtcbiAgICAgICAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsdWUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuZGVmaW5lcy5BTFBIQV9UT19DT1ZFUkFHRSA9ICcnO1xuICAgICAgICAgICAgdGhpcy5leHRlbnNpb25zLmRlcml2YXRpdmVzID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuZGVmaW5lcy5BTFBIQV9UT19DT1ZFUkFHRTtcbiAgICAgICAgICAgIHRoaXMuZXh0ZW5zaW9ucy5kZXJpdmF0aXZlcyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuc2V0VmFsdWVzKHBhcmFtZXRlcnMpO1xuICB9XG59XG5MaW5lTWF0ZXJpYWwucHJvdG90eXBlLmlzTGluZU1hdGVyaWFsID0gdHJ1ZTtcblxuY29uc3QgVEhSRUUgPSB3aW5kb3cuVEhSRUUgPyB3aW5kb3cuVEhSRUUgLy8gUHJlZmVyIGNvbnN1bXB0aW9uIGZyb20gZ2xvYmFsIFRIUkVFLCBpZiBleGlzdHNcbjoge1xuICBCb3gzLFxuICBCdWZmZXJHZW9tZXRyeSxcbiAgSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIsXG4gIEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlLFxuICBMaW5lMyxcbiAgTWF0aFV0aWxzLFxuICBNYXRyaXg0LFxuICBNZXNoLFxuICBTcGhlcmUsXG4gIFZlY3RvcjMsXG4gIFZlY3RvcjRcbn07XG5cbi8vIHN1cHBvcnQgYm90aCBtb2RlcyBmb3IgYmFja3dhcmRzIHRocmVlanMgY29tcGF0aWJpbGl0eVxudmFyIHNldEF0dHJpYnV0ZUZuID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCkuc2V0QXR0cmlidXRlID8gJ3NldEF0dHJpYnV0ZScgOiAnYWRkQXR0cmlidXRlJztcbmNvbnN0IF9zdGFydCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5jb25zdCBfZW5kID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbmNvbnN0IF9zdGFydDQgPSBuZXcgVEhSRUUuVmVjdG9yNCgpO1xuY29uc3QgX2VuZDQgPSBuZXcgVEhSRUUuVmVjdG9yNCgpO1xuY29uc3QgX3NzT3JpZ2luID0gbmV3IFRIUkVFLlZlY3RvcjQoKTtcbmNvbnN0IF9zc09yaWdpbjMgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuY29uc3QgX212TWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcbmNvbnN0IF9saW5lID0gbmV3IFRIUkVFLkxpbmUzKCk7XG5jb25zdCBfY2xvc2VzdFBvaW50ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbmNvbnN0IF9ib3ggPSBuZXcgVEhSRUUuQm94MygpO1xuY29uc3QgX3NwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoKTtcbmNvbnN0IF9jbGlwVG9Xb3JsZFZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3I0KCk7XG5jbGFzcyBMaW5lU2VnbWVudHMyIGV4dGVuZHMgVEhSRUUuTWVzaCB7XG4gIGNvbnN0cnVjdG9yKGdlb21ldHJ5ID0gbmV3IExpbmVTZWdtZW50c0dlb21ldHJ5KCksIG1hdGVyaWFsID0gbmV3IExpbmVNYXRlcmlhbCh7XG4gICAgY29sb3I6IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZlxuICB9KSkge1xuICAgIHN1cGVyKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG4gICAgdGhpcy50eXBlID0gJ0xpbmVTZWdtZW50czInO1xuICB9IC8vIGZvciBiYWNrd2FyZHMtY29tcGF0YWJpbGl0eSwgYnV0IGNvdWxkIGJlIGEgbWV0aG9kIG9mIExpbmVTZWdtZW50c0dlb21ldHJ5Li4uXG5cbiAgY29tcHV0ZUxpbmVEaXN0YW5jZXMoKSB7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuICAgIGNvbnN0IGluc3RhbmNlU3RhcnQgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLmluc3RhbmNlU3RhcnQ7XG4gICAgY29uc3QgaW5zdGFuY2VFbmQgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLmluc3RhbmNlRW5kO1xuICAgIGNvbnN0IGxpbmVEaXN0YW5jZXMgPSBuZXcgRmxvYXQzMkFycmF5KDIgKiBpbnN0YW5jZVN0YXJ0LmNvdW50KTtcbiAgICBmb3IgKGxldCBpID0gMCwgaiA9IDAsIGwgPSBpbnN0YW5jZVN0YXJ0LmNvdW50OyBpIDwgbDsgaSsrLCBqICs9IDIpIHtcbiAgICAgIF9zdGFydC5mcm9tQnVmZmVyQXR0cmlidXRlKGluc3RhbmNlU3RhcnQsIGkpO1xuICAgICAgX2VuZC5mcm9tQnVmZmVyQXR0cmlidXRlKGluc3RhbmNlRW5kLCBpKTtcbiAgICAgIGxpbmVEaXN0YW5jZXNbal0gPSBqID09PSAwID8gMCA6IGxpbmVEaXN0YW5jZXNbaiAtIDFdO1xuICAgICAgbGluZURpc3RhbmNlc1tqICsgMV0gPSBsaW5lRGlzdGFuY2VzW2pdICsgX3N0YXJ0LmRpc3RhbmNlVG8oX2VuZCk7XG4gICAgfVxuICAgIGNvbnN0IGluc3RhbmNlRGlzdGFuY2VCdWZmZXIgPSBuZXcgVEhSRUUuSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIobGluZURpc3RhbmNlcywgMiwgMSk7IC8vIGQwLCBkMVxuXG4gICAgZ2VvbWV0cnlbc2V0QXR0cmlidXRlRm5dKCdpbnN0YW5jZURpc3RhbmNlU3RhcnQnLCBuZXcgVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUoaW5zdGFuY2VEaXN0YW5jZUJ1ZmZlciwgMSwgMCkpOyAvLyBkMFxuXG4gICAgZ2VvbWV0cnlbc2V0QXR0cmlidXRlRm5dKCdpbnN0YW5jZURpc3RhbmNlRW5kJywgbmV3IFRIUkVFLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlKGluc3RhbmNlRGlzdGFuY2VCdWZmZXIsIDEsIDEpKTsgLy8gZDFcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJheWNhc3QocmF5Y2FzdGVyLCBpbnRlcnNlY3RzKSB7XG4gICAgaWYgKHJheWNhc3Rlci5jYW1lcmEgPT09IG51bGwpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0xpbmVTZWdtZW50czI6IFwiUmF5Y2FzdGVyLmNhbWVyYVwiIG5lZWRzIHRvIGJlIHNldCBpbiBvcmRlciB0byByYXljYXN0IGFnYWluc3QgTGluZVNlZ21lbnRzMi4nKTtcbiAgICB9XG4gICAgY29uc3QgdGhyZXNob2xkID0gcmF5Y2FzdGVyLnBhcmFtcy5MaW5lMiAhPT0gdW5kZWZpbmVkID8gcmF5Y2FzdGVyLnBhcmFtcy5MaW5lMi50aHJlc2hvbGQgfHwgMCA6IDA7XG4gICAgY29uc3QgcmF5ID0gcmF5Y2FzdGVyLnJheTtcbiAgICBjb25zdCBjYW1lcmEgPSByYXljYXN0ZXIuY2FtZXJhO1xuICAgIGNvbnN0IHByb2plY3Rpb25NYXRyaXggPSBjYW1lcmEucHJvamVjdGlvbk1hdHJpeDtcbiAgICBjb25zdCBtYXRyaXhXb3JsZCA9IHRoaXMubWF0cml4V29ybGQ7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuICAgIGNvbnN0IG1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbDtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gbWF0ZXJpYWwucmVzb2x1dGlvbjtcbiAgICBjb25zdCBsaW5lV2lkdGggPSBtYXRlcmlhbC5saW5ld2lkdGggKyB0aHJlc2hvbGQ7XG4gICAgY29uc3QgaW5zdGFuY2VTdGFydCA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMuaW5zdGFuY2VTdGFydDtcbiAgICBjb25zdCBpbnN0YW5jZUVuZCA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMuaW5zdGFuY2VFbmQ7IC8vIGNhbWVyYSBmb3J3YXJkIGlzIG5lZ2F0aXZlXG5cbiAgICBjb25zdCBuZWFyID0gLWNhbWVyYS5uZWFyOyAvLyBjbGlwIHNwYWNlIGlzIFsgLSAxLCAxIF0gc28gbXVsdGlwbHkgYnkgdHdvIHRvIGdldCB0aGUgZnVsbFxuICAgIC8vIHdpZHRoIGluIGNsaXAgc3BhY2VcblxuICAgIGNvbnN0IHNzTWF4V2lkdGggPSAyLjAgKiBNYXRoLm1heChsaW5lV2lkdGggLyByZXNvbHV0aW9uLndpZHRoLCBsaW5lV2lkdGggLyByZXNvbHV0aW9uLmhlaWdodCk7IC8vXG4gICAgLy8gY2hlY2sgaWYgd2UgaW50ZXJzZWN0IHRoZSBzcGhlcmUgYm91bmRzXG5cbiAgICBpZiAoZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPT09IG51bGwpIHtcbiAgICAgIGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuICAgIH1cbiAgICBfc3BoZXJlLmNvcHkoZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUpLmFwcGx5TWF0cml4NChtYXRyaXhXb3JsZCk7XG4gICAgY29uc3QgZGlzdGFuY2VUb1NwaGVyZSA9IE1hdGgubWF4KGNhbWVyYS5uZWFyLCBfc3BoZXJlLmRpc3RhbmNlVG9Qb2ludChyYXkub3JpZ2luKSk7IC8vIGdldCB0aGUgdyBjb21wb25lbnQgdG8gc2NhbGUgdGhlIHdvcmxkIHNwYWNlIGxpbmUgd2lkdGhcblxuICAgIF9jbGlwVG9Xb3JsZFZlY3Rvci5zZXQoMCwgMCwgLWRpc3RhbmNlVG9TcGhlcmUsIDEuMCkuYXBwbHlNYXRyaXg0KGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4KTtcbiAgICBfY2xpcFRvV29ybGRWZWN0b3IubXVsdGlwbHlTY2FsYXIoMS4wIC8gX2NsaXBUb1dvcmxkVmVjdG9yLncpO1xuICAgIF9jbGlwVG9Xb3JsZFZlY3Rvci5hcHBseU1hdHJpeDQoY2FtZXJhLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlKTsgLy8gaW5jcmVhc2UgdGhlIHNwaGVyZSBib3VuZHMgYnkgdGhlIHdvcnN0IGNhc2UgbGluZSBzY3JlZW4gc3BhY2Ugd2lkdGhcblxuICAgIGNvbnN0IHNwaGVyZU1hcmdpbiA9IE1hdGguYWJzKHNzTWF4V2lkdGggLyBfY2xpcFRvV29ybGRWZWN0b3IudykgKiAwLjU7XG4gICAgX3NwaGVyZS5yYWRpdXMgKz0gc3BoZXJlTWFyZ2luO1xuICAgIGlmIChyYXljYXN0ZXIucmF5LmludGVyc2VjdHNTcGhlcmUoX3NwaGVyZSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvL1xuICAgIC8vIGNoZWNrIGlmIHdlIGludGVyc2VjdCB0aGUgYm94IGJvdW5kc1xuXG4gICAgaWYgKGdlb21ldHJ5LmJvdW5kaW5nQm94ID09PSBudWxsKSB7XG4gICAgICBnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdCb3goKTtcbiAgICB9XG4gICAgX2JveC5jb3B5KGdlb21ldHJ5LmJvdW5kaW5nQm94KS5hcHBseU1hdHJpeDQobWF0cml4V29ybGQpO1xuICAgIGNvbnN0IGRpc3RhbmNlVG9Cb3ggPSBNYXRoLm1heChjYW1lcmEubmVhciwgX2JveC5kaXN0YW5jZVRvUG9pbnQocmF5Lm9yaWdpbikpOyAvLyBnZXQgdGhlIHcgY29tcG9uZW50IHRvIHNjYWxlIHRoZSB3b3JsZCBzcGFjZSBsaW5lIHdpZHRoXG5cbiAgICBfY2xpcFRvV29ybGRWZWN0b3Iuc2V0KDAsIDAsIC1kaXN0YW5jZVRvQm94LCAxLjApLmFwcGx5TWF0cml4NChjYW1lcmEucHJvamVjdGlvbk1hdHJpeCk7XG4gICAgX2NsaXBUb1dvcmxkVmVjdG9yLm11bHRpcGx5U2NhbGFyKDEuMCAvIF9jbGlwVG9Xb3JsZFZlY3Rvci53KTtcbiAgICBfY2xpcFRvV29ybGRWZWN0b3IuYXBwbHlNYXRyaXg0KGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZSk7IC8vIGluY3JlYXNlIHRoZSBzcGhlcmUgYm91bmRzIGJ5IHRoZSB3b3JzdCBjYXNlIGxpbmUgc2NyZWVuIHNwYWNlIHdpZHRoXG5cbiAgICBjb25zdCBib3hNYXJnaW4gPSBNYXRoLmFicyhzc01heFdpZHRoIC8gX2NsaXBUb1dvcmxkVmVjdG9yLncpICogMC41O1xuICAgIF9ib3gubWF4LnggKz0gYm94TWFyZ2luO1xuICAgIF9ib3gubWF4LnkgKz0gYm94TWFyZ2luO1xuICAgIF9ib3gubWF4LnogKz0gYm94TWFyZ2luO1xuICAgIF9ib3gubWluLnggLT0gYm94TWFyZ2luO1xuICAgIF9ib3gubWluLnkgLT0gYm94TWFyZ2luO1xuICAgIF9ib3gubWluLnogLT0gYm94TWFyZ2luO1xuICAgIGlmIChyYXljYXN0ZXIucmF5LmludGVyc2VjdHNCb3goX2JveCkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvL1xuICAgIC8vIHBpY2sgYSBwb2ludCAxIHVuaXQgb3V0IGFsb25nIHRoZSByYXkgdG8gYXZvaWQgdGhlIHJheSBvcmlnaW5cbiAgICAvLyBzaXR0aW5nIGF0IHRoZSBjYW1lcmEgb3JpZ2luIHdoaWNoIHdpbGwgY2F1c2UgXCJ3XCIgdG8gYmUgMCB3aGVuXG4gICAgLy8gYXBwbHlpbmcgdGhlIHByb2plY3Rpb24gbWF0cml4LlxuXG4gICAgcmF5LmF0KDEsIF9zc09yaWdpbik7IC8vIG5kYyBzcGFjZSBbIC0gMS4wLCAxLjAgXVxuXG4gICAgX3NzT3JpZ2luLncgPSAxO1xuICAgIF9zc09yaWdpbi5hcHBseU1hdHJpeDQoY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSk7XG4gICAgX3NzT3JpZ2luLmFwcGx5TWF0cml4NChwcm9qZWN0aW9uTWF0cml4KTtcbiAgICBfc3NPcmlnaW4ubXVsdGlwbHlTY2FsYXIoMSAvIF9zc09yaWdpbi53KTsgLy8gc2NyZWVuIHNwYWNlXG5cbiAgICBfc3NPcmlnaW4ueCAqPSByZXNvbHV0aW9uLnggLyAyO1xuICAgIF9zc09yaWdpbi55ICo9IHJlc29sdXRpb24ueSAvIDI7XG4gICAgX3NzT3JpZ2luLnogPSAwO1xuICAgIF9zc09yaWdpbjMuY29weShfc3NPcmlnaW4pO1xuICAgIF9tdk1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UsIG1hdHJpeFdvcmxkKTtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IGluc3RhbmNlU3RhcnQuY291bnQ7IGkgPCBsOyBpKyspIHtcbiAgICAgIF9zdGFydDQuZnJvbUJ1ZmZlckF0dHJpYnV0ZShpbnN0YW5jZVN0YXJ0LCBpKTtcbiAgICAgIF9lbmQ0LmZyb21CdWZmZXJBdHRyaWJ1dGUoaW5zdGFuY2VFbmQsIGkpO1xuICAgICAgX3N0YXJ0NC53ID0gMTtcbiAgICAgIF9lbmQ0LncgPSAxOyAvLyBjYW1lcmEgc3BhY2VcblxuICAgICAgX3N0YXJ0NC5hcHBseU1hdHJpeDQoX212TWF0cml4KTtcbiAgICAgIF9lbmQ0LmFwcGx5TWF0cml4NChfbXZNYXRyaXgpOyAvLyBza2lwIHRoZSBzZWdtZW50IGlmIGl0J3MgZW50aXJlbHkgYmVoaW5kIHRoZSBjYW1lcmFcblxuICAgICAgdmFyIGlzQmVoaW5kQ2FtZXJhTmVhciA9IF9zdGFydDQueiA+IG5lYXIgJiYgX2VuZDQueiA+IG5lYXI7XG4gICAgICBpZiAoaXNCZWhpbmRDYW1lcmFOZWFyKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyB0cmltIHRoZSBzZWdtZW50IGlmIGl0IGV4dGVuZHMgYmVoaW5kIGNhbWVyYSBuZWFyXG5cbiAgICAgIGlmIChfc3RhcnQ0LnogPiBuZWFyKSB7XG4gICAgICAgIGNvbnN0IGRlbHRhRGlzdCA9IF9zdGFydDQueiAtIF9lbmQ0Lno7XG4gICAgICAgIGNvbnN0IHQgPSAoX3N0YXJ0NC56IC0gbmVhcikgLyBkZWx0YURpc3Q7XG4gICAgICAgIF9zdGFydDQubGVycChfZW5kNCwgdCk7XG4gICAgICB9IGVsc2UgaWYgKF9lbmQ0LnogPiBuZWFyKSB7XG4gICAgICAgIGNvbnN0IGRlbHRhRGlzdCA9IF9lbmQ0LnogLSBfc3RhcnQ0Lno7XG4gICAgICAgIGNvbnN0IHQgPSAoX2VuZDQueiAtIG5lYXIpIC8gZGVsdGFEaXN0O1xuICAgICAgICBfZW5kNC5sZXJwKF9zdGFydDQsIHQpO1xuICAgICAgfSAvLyBjbGlwIHNwYWNlXG5cbiAgICAgIF9zdGFydDQuYXBwbHlNYXRyaXg0KHByb2plY3Rpb25NYXRyaXgpO1xuICAgICAgX2VuZDQuYXBwbHlNYXRyaXg0KHByb2plY3Rpb25NYXRyaXgpOyAvLyBuZGMgc3BhY2UgWyAtIDEuMCwgMS4wIF1cblxuICAgICAgX3N0YXJ0NC5tdWx0aXBseVNjYWxhcigxIC8gX3N0YXJ0NC53KTtcbiAgICAgIF9lbmQ0Lm11bHRpcGx5U2NhbGFyKDEgLyBfZW5kNC53KTsgLy8gc2NyZWVuIHNwYWNlXG5cbiAgICAgIF9zdGFydDQueCAqPSByZXNvbHV0aW9uLnggLyAyO1xuICAgICAgX3N0YXJ0NC55ICo9IHJlc29sdXRpb24ueSAvIDI7XG4gICAgICBfZW5kNC54ICo9IHJlc29sdXRpb24ueCAvIDI7XG4gICAgICBfZW5kNC55ICo9IHJlc29sdXRpb24ueSAvIDI7IC8vIGNyZWF0ZSAyZCBzZWdtZW50XG5cbiAgICAgIF9saW5lLnN0YXJ0LmNvcHkoX3N0YXJ0NCk7XG4gICAgICBfbGluZS5zdGFydC56ID0gMDtcbiAgICAgIF9saW5lLmVuZC5jb3B5KF9lbmQ0KTtcbiAgICAgIF9saW5lLmVuZC56ID0gMDsgLy8gZ2V0IGNsb3Nlc3QgcG9pbnQgb24gcmF5IHRvIHNlZ21lbnRcblxuICAgICAgY29uc3QgcGFyYW0gPSBfbGluZS5jbG9zZXN0UG9pbnRUb1BvaW50UGFyYW1ldGVyKF9zc09yaWdpbjMsIHRydWUpO1xuICAgICAgX2xpbmUuYXQocGFyYW0sIF9jbG9zZXN0UG9pbnQpOyAvLyBjaGVjayBpZiB0aGUgaW50ZXJzZWN0aW9uIHBvaW50IGlzIHdpdGhpbiBjbGlwIHNwYWNlXG5cbiAgICAgIGNvbnN0IHpQb3MgPSBUSFJFRS5NYXRoVXRpbHMubGVycChfc3RhcnQ0LnosIF9lbmQ0LnosIHBhcmFtKTtcbiAgICAgIGNvbnN0IGlzSW5DbGlwU3BhY2UgPSB6UG9zID49IC0xICYmIHpQb3MgPD0gMTtcbiAgICAgIGNvbnN0IGlzSW5zaWRlID0gX3NzT3JpZ2luMy5kaXN0YW5jZVRvKF9jbG9zZXN0UG9pbnQpIDwgbGluZVdpZHRoICogMC41O1xuICAgICAgaWYgKGlzSW5DbGlwU3BhY2UgJiYgaXNJbnNpZGUpIHtcbiAgICAgICAgX2xpbmUuc3RhcnQuZnJvbUJ1ZmZlckF0dHJpYnV0ZShpbnN0YW5jZVN0YXJ0LCBpKTtcbiAgICAgICAgX2xpbmUuZW5kLmZyb21CdWZmZXJBdHRyaWJ1dGUoaW5zdGFuY2VFbmQsIGkpO1xuICAgICAgICBfbGluZS5zdGFydC5hcHBseU1hdHJpeDQobWF0cml4V29ybGQpO1xuICAgICAgICBfbGluZS5lbmQuYXBwbHlNYXRyaXg0KG1hdHJpeFdvcmxkKTtcbiAgICAgICAgY29uc3QgcG9pbnRPbkxpbmUgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICBjb25zdCBwb2ludCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgIHJheS5kaXN0YW5jZVNxVG9TZWdtZW50KF9saW5lLnN0YXJ0LCBfbGluZS5lbmQsIHBvaW50LCBwb2ludE9uTGluZSk7XG4gICAgICAgIGludGVyc2VjdHMucHVzaCh7XG4gICAgICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgICAgIHBvaW50T25MaW5lOiBwb2ludE9uTGluZSxcbiAgICAgICAgICBkaXN0YW5jZTogcmF5Lm9yaWdpbi5kaXN0YW5jZVRvKHBvaW50KSxcbiAgICAgICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICAgICAgZmFjZTogbnVsbCxcbiAgICAgICAgICBmYWNlSW5kZXg6IGksXG4gICAgICAgICAgdXY6IG51bGwsXG4gICAgICAgICAgdXYyOiBudWxsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuTGluZVNlZ21lbnRzMi5wcm90b3R5cGUuTGluZVNlZ21lbnRzMiA9IHRydWU7XG5cbmNsYXNzIExpbmVHZW9tZXRyeSBleHRlbmRzIExpbmVTZWdtZW50c0dlb21ldHJ5IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnR5cGUgPSAnTGluZUdlb21ldHJ5JztcbiAgfVxuICBzZXRQb3NpdGlvbnMoYXJyYXkpIHtcbiAgICAvLyBjb252ZXJ0cyBbIHgxLCB5MSwgejEsICB4MiwgeTIsIHoyLCAuLi4gXSB0byBwYWlycyBmb3JtYXRcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIC0gMztcbiAgICB2YXIgcG9pbnRzID0gbmV3IEZsb2F0MzJBcnJheSgyICogbGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAzKSB7XG4gICAgICBwb2ludHNbMiAqIGldID0gYXJyYXlbaV07XG4gICAgICBwb2ludHNbMiAqIGkgKyAxXSA9IGFycmF5W2kgKyAxXTtcbiAgICAgIHBvaW50c1syICogaSArIDJdID0gYXJyYXlbaSArIDJdO1xuICAgICAgcG9pbnRzWzIgKiBpICsgM10gPSBhcnJheVtpICsgM107XG4gICAgICBwb2ludHNbMiAqIGkgKyA0XSA9IGFycmF5W2kgKyA0XTtcbiAgICAgIHBvaW50c1syICogaSArIDVdID0gYXJyYXlbaSArIDVdO1xuICAgIH1cbiAgICBzdXBlci5zZXRQb3NpdGlvbnMocG9pbnRzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzZXRDb2xvcnMoYXJyYXkpIHtcbiAgICAvLyBjb252ZXJ0cyBbIHIxLCBnMSwgYjEsICByMiwgZzIsIGIyLCAuLi4gXSB0byBwYWlycyBmb3JtYXRcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIC0gMztcbiAgICB2YXIgY29sb3JzID0gbmV3IEZsb2F0MzJBcnJheSgyICogbGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAzKSB7XG4gICAgICBjb2xvcnNbMiAqIGldID0gYXJyYXlbaV07XG4gICAgICBjb2xvcnNbMiAqIGkgKyAxXSA9IGFycmF5W2kgKyAxXTtcbiAgICAgIGNvbG9yc1syICogaSArIDJdID0gYXJyYXlbaSArIDJdO1xuICAgICAgY29sb3JzWzIgKiBpICsgM10gPSBhcnJheVtpICsgM107XG4gICAgICBjb2xvcnNbMiAqIGkgKyA0XSA9IGFycmF5W2kgKyA0XTtcbiAgICAgIGNvbG9yc1syICogaSArIDVdID0gYXJyYXlbaSArIDVdO1xuICAgIH1cbiAgICBzdXBlci5zZXRDb2xvcnMoY29sb3JzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBmcm9tTGluZShsaW5lKSB7XG4gICAgdmFyIGdlb21ldHJ5ID0gbGluZS5nZW9tZXRyeTtcbiAgICBpZiAoZ2VvbWV0cnkuaXNHZW9tZXRyeSkge1xuICAgICAgY29uc29sZS5lcnJvcignVEhSRUUuTGluZUdlb21ldHJ5IG5vIGxvbmdlciBzdXBwb3J0cyBHZW9tZXRyeS4gVXNlIFRIUkVFLkJ1ZmZlckdlb21ldHJ5IGluc3RlYWQuJyk7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChnZW9tZXRyeS5pc0J1ZmZlckdlb21ldHJ5KSB7XG4gICAgICB0aGlzLnNldFBvc2l0aW9ucyhnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5KTsgLy8gYXNzdW1lcyBub24taW5kZXhlZFxuICAgIH0gLy8gc2V0IGNvbG9ycywgbWF5YmVcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5MaW5lR2VvbWV0cnkucHJvdG90eXBlLmlzTGluZUdlb21ldHJ5ID0gdHJ1ZTtcblxuY2xhc3MgTGluZTIgZXh0ZW5kcyBMaW5lU2VnbWVudHMyIHtcbiAgY29uc3RydWN0b3IoZ2VvbWV0cnkgPSBuZXcgTGluZUdlb21ldHJ5KCksIG1hdGVyaWFsID0gbmV3IExpbmVNYXRlcmlhbCh7XG4gICAgY29sb3I6IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZlxuICB9KSkge1xuICAgIHN1cGVyKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG4gICAgdGhpcy50eXBlID0gJ0xpbmUyJztcbiAgfVxufVxuTGluZTIucHJvdG90eXBlLmlzTGluZTIgPSB0cnVlO1xuXG5leHBvcnQgeyBMaW5lMiwgTGluZUdlb21ldHJ5LCBMaW5lTWF0ZXJpYWwsIExpbmVTZWdtZW50czIsIExpbmVTZWdtZW50c0dlb21ldHJ5IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-fatline/dist/three-fatline.mjs\n");

/***/ })

};
;